<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STARSHIP HMI - FLIGHT CONTROL & WORKSTATION (V12 - Novastella)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
    
    
        /* --- STARSHIP AESTHETICS (BLUE/CYAN/ORANGE THEME) --- */
        :root {
            --star-blue: #00e0ff; /* ä¸»é’è“è‰²è°ƒ */
            --star-glow: #88ffff; /* äº®é’è‰²å…‰æ™• */
            --star-orange: #ffaa00; /* æ–°å¢ï¼šå¼ºè°ƒæ©™è‰²/ç¥ç€è‰² */
            --star-orange-glow: #ffc466; /* æ–°å¢ï¼šäº®æ©™è‰²å…‰æ™• */
            --alert-red: #ff3300; /* è­¦æŠ¥æ·±çº¢è‰² */
            --glass-bg: rgba(0, 15, 20, 0.7); /* æ·±è“è‰²ç»ç’ƒèƒŒæ™¯ */
            --font-main: 'Roboto Mono', monospace; /* ä¸»å­—ä½“ */
        }
/* --- æµè§ˆå™¨æµ®çª—è§¦å‘å™¨ (#browser-trigger-area) æ ·å¼ --- */
#browser-trigger-area {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 1000; /* ç¡®ä¿å®ƒèƒ½è¢«ç‚¹å‡» */
    pointer-events: auto;
}

/* --- æµè§ˆå™¨æµ®çª—å®¹å™¨ (#browser-widget) æ ·å¼ --- */
#browser-widget {
    /* æ ¸å¿ƒå®šä½å’Œå±‚çº§ */
    position: absolute; 
    z-index: 9990; 
    transform: translate(-50%, -50%); /* ä¿æŒå±…ä¸­å®šä½ï¼ˆæ‹–åŠ¨æ—¶è¢«JSè¦†ç›–ï¼‰ */
    
    /* æ ¸å¿ƒå¸ƒå±€ï¼šå‚ç›´æ–¹å‘æ’åˆ— */
    display: flex;
    flex-direction: column;

    /* é»˜è®¤å¤§å°å’Œå¤–è§‚ */
    width: 800px;
    height: 500px;
    background: rgba(10, 20, 30, 0.95);
    border: 2px solid var(--star-glow);
    box-shadow: 0 0 15px var(--star-glow);

    /* ------------------------------------------------ */
    /* å…³é”®ä¿®å¤ï¼šå…è®¸ç”¨æˆ·æ‰‹åŠ¨ç¼©æ”¾æµ®çª— */
    resize: both; /* å…è®¸æ°´å¹³å’Œå‚ç›´ç¼©æ”¾ */
    overflow: auto; /* ç¡®ä¿æ‹–åŠ¨åŒºåŸŸå’Œå†…å®¹åœ¨ç¼©æ”¾æ—¶èƒ½æ­£ç¡®å¤„ç†æº¢å‡º */
    min-width: 400px; /* æœ€å°å®½åº¦é™åˆ¶ */
    min-height: 500px; /* æœ€å°é«˜åº¦é™åˆ¶ï¼Œé˜²æ­¢ç¼©æ”¾å¤ªå° */
    /* ------------------------------------------------ */
}

/* --- åœ°å€æ å®¹å™¨ (#web-controls-bar) æ ·å¼ --- */
#web-controls-bar {
    padding: 5px 10px; 
    background: rgba(0, 0, 0, 0.4);
    border-bottom: 1px solid var(--star-blue);
    flex-shrink: 0; /* ç¡®ä¿å®ƒä¸ä¼šè¢«å‹ç¼© */
}

/* --- åœ°å€æ è¾“å…¥æ¡† (#web-address-bar) æ ·å¼ --- */
#web-address-bar {
    width: 100%;
    box-sizing: border-box;
    padding: 5px 8px;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid var(--star-blue);
    color: var(--star-glow);
    font-size: 14px;
    outline: none;
}

/* --- Iframe æ ·å¼ (å æ®å‰©ä½™ç©ºé—´) --- */
#embedded-iframe {
    width: 100%;
    border: none;
    flex-grow: 1; /* å æ® #browser-widget å®¹å™¨å†…æ‰€æœ‰å‰©ä½™çš„å‚ç›´ç©ºé—´ */
    min-height: 100px;
    background: #000;
}
        /* --- å…¨å±€æ»šåŠ¨æ¡ç¾åŒ– (HMI Aesthetic) --- */
        ::-webkit-scrollbar {
            width: 8px; /* æ»šåŠ¨æ¡çš„å®½åº¦ (å‚ç›´) */
            height: 8px; /* æ»šåŠ¨æ¡çš„é«˜åº¦ (æ°´å¹³) */
        }
        ::-webkit-scrollbar-track {
            background: rgba(0, 20, 40, 0.4); /* æ·±è“è‰²åŠé€æ˜èƒŒæ™¯ */
        }
        ::-webkit-scrollbar-thumb {
            background-color: var(--star-blue); /* æ»‘å—é¢œè‰²ï¼šé’è“ */
            border-radius: 4px;
            border: 1px solid var(--star-glow);
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--star-orange); /* æ‚¬åœæ—¶å˜æ©™è‰² */
            border-color: var(--star-orange-glow);
            cursor: pointer;
        }
        ::-webkit-scrollbar-corner {
            background: transparent;
        }

        body {
            margin: 0; padding: 0;
            background-color: #000;
            color: var(--star-blue);
            font-family: var(--font-main);
            overflow: hidden;
            height: 100vh; width: 100vw;
            user-select: none;
            cursor: none;
        }

        /* --- FONT FIXES --- */
        #hex-dump, #log-feed, .music-player-link-input, .reminder-input-field {
            font-family: 'Consolas', 'Courier New', monospace;
        }

        /* --- LAYERS --- */
        #cam-feed {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
            z-index: 1; opacity: 1;
            filter: contrast(0.95) brightness(0.7) saturate(1.15) hue-rotate(10deg) blur(0.5px);	
        }

        #hand-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 999; transform: scaleX(-1); pointer-events: none;
        }

        #vignette {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at center, transparent 30%, #000 120%);
            z-index: 2; pointer-events: none;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
        }
        
        /* Boot Screen */
        #boot-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s;
        }
        .boot-btn {
            padding: 15px 30px; font-size: 20px;
            background: var(--star-blue); color: #000;
            border: none; cursor: pointer;
            box-shadow: 0 0 20px var(--star-glow);
            font-family: var(--font-main);
            letter-spacing: 2px;
        }
        .boot-btn:hover { background: var(--star-glow); }

        /* --- UI CONTAINER --- */
        #ui-layer {
            position: relative; z-index: 10; width: 100%; height: 100%;
            pointer-events: none;
            perspective: 1000px;
        }

        /* --- WIDGETS --- */
        .top-bar {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 40px; align-items: center;
        }
        .hud-tag {
            font-size: 15px; letter-spacing: 2px; color: var(--star-glow);
            border-bottom: 1px solid var(--star-blue); padding-bottom: 2px;
            text-shadow: 0 0 10px var(--star-blue);
        }

        .left-panel {
            position: absolute; left: 50px; top: 15%;
            transform: rotateY(5deg);	
            display: flex; flex-direction: column; gap: 20px;
            width: 250px;
            pointer-events: none;	
        }
        .stat-group { display: flex; flex-direction: column; gap: 8px; }
        .bar-frame { width: 100%; height: 6px; background: rgba(0, 100, 255, 0.2); }
        .bar-fill { height: 100%; background: var(--star-blue); width: 0%; transition: width 0.5s; box-shadow: 0 0 10px var(--star-blue); }
        .bar-fill.active { width: 95%; animation: pulseBar 2s infinite; }
        .label-text { font-size: 11px; color: var(--star-blue); letter-spacing: 2px; font-weight: bold; }
        .box-container {	
            border: 1px solid var(--star-blue);	
            padding: 15px;
            background: var(--glass-bg);	
            box-shadow: inset 0 0 5px rgba(0, 224, 255, 0.2);
            pointer-events: auto;	
        }
        .weather-val { font-size: 20px; color: #fff; font-weight: bold; text-shadow: 0 0 10px var(--star-glow); }
        .weather-sub { font-size: 12px; color: var(--star-blue); opacity: 0.8; }
        #hex-dump {
            font-size: 11px;
            color: rgba(0, 224, 255, 0.7); line-height: 1.4;	
            margin-top: 5px; height: 40px; overflow: hidden;
        }

        /* Right Radar (MAP) */
        .right-panel {
            position: absolute; right: 50px; top: 15%;
            width: 450px; height: 450px;
            transform: rotateY(-5deg);
            transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: auto;
        }
        .right-panel.fullscreen {
            top: 0; right: 0; bottom: 0; left: 0;
            width: 100vw; height: 100vh;
            transform: none;	
            background: rgba(0,0,0,0.9);
            z-index: 90;
        }
        #radar-housing {
            width: 100%; height: 100%;
            border-radius: 8px;
            border: 2px solid var(--star-blue);
            position: relative; overflow: hidden;
            background: rgba(0, 15, 20, 0.9);
            box-shadow: 0 0 30px rgba(0, 224, 255, 0.3);
            transition: border-radius 0.5s;
        }
        .right-panel.fullscreen #radar-housing { border-radius: 0; border: none; }
        #map-layer { width: 100%; height: 100%; opacity: 0; transition: opacity 1s; }
        #map-layer.active { opacity: 1; }
        #map { width: 100%; height: 100%; background: #000; }
        .leaflet-layer {
            filter: grayscale(100%) sepia(50%) hue-rotate(180deg) saturate(300%) contrast(1.2) brightness(0.8);
            opacity: 0.95;	
            transition: filter 1.5s ease;
        }
        .leaflet-layer.true-color { filter: none !important; opacity: 1; }
        #radar-sweep {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: conic-gradient(from 0deg, transparent 70%, rgba(0, 224, 255, 0.1) 90%, rgba(136, 255, 255, 0.6) 100%);
            border-radius: 50%; animation: spin 4s linear infinite;
            pointer-events: none; mix-blend-mode: screen; z-index: 10;
        }

        /* Exit Fullscreen Button */
        #exit-fullscreen-btn {
            position: absolute; top: 15px; right: 15px;
            background: var(--alert-red); color: #000;
            border: none; padding: 5px 10px;
            font-size: 14px; cursor: pointer;
            z-index: 95;	
            display: none;
            box-shadow: 0 0 10px var(--alert-red);
            pointer-events: auto;
            font-family: var(--font-main);
        }
        .right-panel.fullscreen #exit-fullscreen-btn {
            display: block;	
        }


        /* Bottom Console */
        .bottom-console {
            position: absolute; bottom: 40px; left: 50px;
            width: 400px;
            transform: rotateX(5deg);
            pointer-events: none;	
        }
        #log-feed {
            font-size: 13px;
            color: rgba(0, 224, 255, 0.6); height: 120px;	
            overflow: hidden; display: flex; flex-direction: column-reverse;
            text-shadow: 0 0 2px var(--star-blue);
        }
        .msg-sys { color: var(--star-glow); }	
        .msg-usr { color: var(--star-orange); } /* å·²ä¿®æ”¹: ç”¨æˆ·è¾“å…¥æ”¹ä¸ºæ©™è‰² */
        .msg-novastella { color: var(--star-blue); font-weight: bold; }	
        .msg-alert { color: var(--alert-red); font-weight: bold; }	

        /* --- TOOL BAR & WIDGETS --- */
        #tool-bar {
            position: absolute; bottom: 40px; right: 50px;
            width: 450px;
            display: flex; gap: 10px;
            justify-content: space-around;
            background: var(--glass-bg);
            border: 1px solid var(--star-blue);
            padding: 10px;
            box-shadow: 0 0 15px rgba(0, 224, 255, 0.2);
            pointer-events: auto;	
            z-index: 50;	
        }
        .tool-btn {
            color: var(--star-blue); font-size: 28px; padding: 5px 10px;
            cursor: pointer; transition: all 0.2s;
            border: 1px solid transparent;
            width: 20%; text-align: center;
        }
        .tool-btn:hover { color: var(--star-glow); box-shadow: 0 0 10px var(--star-blue); }
        .tool-btn.active { 
            color: #000; 
            background: var(--star-orange); /* å·²ä¿®æ”¹: æ¿€æ´»æŒ‰é’®æ”¹ä¸ºæ©™è‰² */
            border-color: var(--star-orange-glow); 
            box-shadow: 0 0 10px var(--star-orange-glow);
        }
        
        .tool-btn[data-tool="map"].active .fa-expand-alt { display: none; }
        .tool-btn[data-tool="map"].active .fa-compress-alt { display: inline; }
        .tool-btn[data-tool="map"] .fa-compress-alt { display: none; }


        /* Floating Widget Styling */
        .work-widget {
            position: absolute;
            top: 50%; left: 50%;	
            transform: translate(-50%, -50%);	
            width: 300px; max-height: 400px;
            z-index: 100;	
            background: var(--glass-bg);
            border: 2px solid var(--star-blue);
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 224, 255, 0.5);
            display: none; /* Initially hidden */
            flex-direction: column;
            pointer-events: auto;	
            /* Added for float styling */
            min-width: 300px;
            min-height: 200px;
            resize: both; /* Allow resizing */
            overflow: auto;
        }
        .widget-header {
            font-size: 14px; letter-spacing: 2px; text-transform: uppercase;
            border-bottom: 1px solid var(--star-blue); padding-bottom: 10px;
            margin-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center;
            cursor: move; /* Make header draggable */
        }
        .widget-close { color: var(--alert-red); cursor: pointer; font-size: 18px; transition: color 0.2s; }
        .widget-close:hover { color: #fff; }

        /* CALENDAR FIX (Existing) */
        #calendar-body {
            display: grid;	
            grid-template-columns: repeat(7, 1fr);	
            text-align: center;	
            font-size: 12px;
            gap: 1px;	
        }
        .day-header { color: var(--star-glow); padding: 5px 0; margin-bottom: 5px; font-size: 10px;}
        .cal-day {	
            padding: 5px 0;	
            border: 1px solid rgba(0, 224, 255, 0.1);	
            cursor: default;	
            background: rgba(0,0,0,0.1);	
        }
        .cal-day:empty { background: transparent; border: none; }
        .cal-day.today { background: var(--star-blue); color: #000; font-weight: bold; }
        .cal-day.event { background: rgba(255, 255, 0, 0.2); }

        /* Reminder Styling (Existing) */
        #reminder-list-container {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid rgba(0, 224, 255, 0.1);
            padding: 5px;
            margin-bottom: 10px;
        }
        #reminder-list {
            list-style: none; padding: 0; margin: 0;	
        }
        .reminder-item {
            padding: 8px; border-bottom: 1px dashed rgba(0, 224, 255, 0.3);
            font-size: 13px;
            display: flex; justify-content: space-between; align-items: flex-start;
            flex-direction: column;
        }
        .reminder-item:last-child { border-bottom: none; }
        .no-reminders { padding: 10px; color: rgba(255, 255, 255, 0.5); font-style: italic; font-size: 12px; }
        
        .reminder-title { font-weight: bold; }
        .reminder-schedule { font-size: 10px; color: var(--star-glow); opacity: 0.8; margin-top: 2px; }

        .add-reminder-btn {
            background: var(--star-blue); color: #000; padding: 8px; border: none; cursor: pointer;
            width: 100%; font-family: var(--font-main);
        }
        .add-reminder-btn:hover { background: var(--star-glow); }

        /* Input fields for reminder (Existing) */
        .reminder-input-field {
            width: calc(100% - 20px); padding: 5px 10px; margin-bottom: 5px;
            background: rgba(0, 224, 255, 0.1); border: 1px solid var(--star-blue);
            color: var(--star-glow); font-size: 10px;
        }
        
        /* --- Music Player Styling (Enhanced) --- */
        #music-widget { width: 450px; max-height: 500px; }
        #music-player { text-align: center; }
        #track-name { font-size: 16px; color: #fff; margin: 10px 0 5px; }
        #artist-name { font-size: 12px; color: var(--star-blue); opacity: 0.8; margin-bottom: 15px; }
        
        .music-controls { display: flex; justify-content: center; gap: 20px; margin-bottom: 15px; }
        .music-btn { font-size: 30px; cursor: pointer; color: var(--star-blue); transition: color 0.2s; }
        .music-btn.play { color: var(--star-glow); }
        .music-btn.active-mode { color: #fff; text-shadow: 0 0 10px var(--star-glow); }
        .music-btn:hover { color: var(--star-glow); }

        .seek-controls { display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; }
        .seek-btn { font-size: 20px; padding: 5px; }

        /* Subtitles/Lyrics Area */
        #subtitle-area {
            height: 100px;
            overflow-y: hidden; /* Hide scrollbar for clean look */
            text-align: center;
            border: 1px solid var(--star-blue);
            padding: 10px;
            font-size: 14px;
            margin-bottom: 10px;
            line-height: 1.5;
        }
        #current-subtitle {
            color: var(--star-glow);
            font-weight: bold;
            text-shadow: 0 0 5px var(--star-glow);
            transition: opacity 0.3s;
        }

        /* Learning/Repeat Controls */
        .learning-controls {
            display: flex; justify-content: center; gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .learn-btn {
            background: rgba(0, 224, 255, 0.1);
            color: var(--star-blue);
            border: 1px solid var(--star-blue);
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .learn-btn:hover { background: var(--star-blue); color: #000; }

        /* Playlist */
        #playlist-section {
            display: flex; flex-direction: column;
            border-top: 1px dashed var(--star-blue);
            padding-top: 10px;
            margin-top: 10px;
        }
        #playlist-list {
            list-style: none;
            padding: 0; margin: 5px 0 10px;
            max-height: 150px; /* Increased height for folders */
            overflow-y: auto;
            font-size: 11px;
            border: 1px solid rgba(0, 224, 255, 0.1);
        }
        
        /* --- Playlist Hierarchy Styling (NEW) --- */
        .playlist-group-header {
            padding: 0;
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 224, 255, 0.3);
            margin: 2px 0;
            list-style: none;	
        }
        .playlist-group-header:hover {
            background: rgba(0, 224, 255, 0.1);
        }
        
        .playlist-item {
            padding: 5px 8px;
            cursor: pointer;
            border-bottom: 1px dashed rgba(0, 224, 255, 0.1);
            text-align: left;
            display: flex;	
            justify-content: space-between;
            align-items: center;
            padding-left: 25px; /* Indent the tracks */
            font-size: 10px; /* Make track text smaller */
        }
        .playlist-item:hover { background: rgba(0, 224, 255, 0.15); }
        .playlist-item.current {
            background: var(--star-blue);
            color: #000;
            font-weight: bold;
        }
        .playlist-item.current span {
            color: #000 !important;
        }
        
        /* Hidden file input */
        #folder-input { display: none; }

        .delete-track-btn {
            color: var(--alert-red);
            font-size: 14px;
            cursor: pointer;
            padding: 0 5px;
            transition: color 0.2s;
        }
        .delete-track-btn:hover {
            color: #fff;
            text-shadow: 0 0 5px var(--alert-red);
        }
      /* --- æµè§ˆå™¨æµ®çª—æ ·å¼ (åŸºäº HMI é£æ ¼) --- */

/* è§¦å‘å›¾æ ‡åŒºåŸŸ */
#browser-trigger-area {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 200; /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ */
    pointer-events: auto; /* å…è®¸ç‚¹å‡» */
}
#browser-logo {
    width: 48px; 
    height: 48px;
    cursor: pointer;
    border: 2px solid var(--star-blue);
    border-radius: 5px;
    transition: all 0.2s;
}
#browser-logo:hover {
    box-shadow: 0 0 10px var(--star-glow);
}

/* æµè§ˆå™¨æµ®çª— */
#browser-widget {
    /* ç»§æ‰¿ .work-widget æ ·å¼ï¼Œä½†è®¾ç½® Flex å¸ƒå±€ */
    display: flex;
    flex-direction: column;
}

/* åœ°å€æ å®¹å™¨ */
#web-controls-bar {
    display: flex;
    padding: 0 0 10px 0;
}

/* åœ°å€æ è¾“å…¥æ¡†æœ¬ä½“ */
#web-address-bar {
    flex-grow: 1;
    height: 30px;
    padding: 0 10px;
    font-family: var(--font-main);
    font-size: 14px;
    
    /* HMI é£æ ¼ */
    background: rgba(0, 0, 0, 0.7);
    color: var(--star-glow);
    border: 1px solid var(--star-blue);
    box-shadow: 0 0 5px rgba(0, 224, 255, 0.3);
    transition: all 0.2s;
}

#web-address-bar:focus {
    outline: none;
    border-color: var(--star-glow);
    box-shadow: 0 0 8px var(--star-glow);
}

/* åµŒå…¥å¼ç½‘é¡µ iframe */
#embedded-iframe {
    width: 100%;
    flex-grow: 1; /* å æ®å‰©ä½™ç©ºé—´ */
    border: 1px solid var(--star-blue); /* ç½‘é¡µå†…å®¹è¾¹æ¡† */
    background-color: #fff; /* é»˜è®¤ç™½è‰²èƒŒæ™¯ï¼ŒåŠ è½½æ—¶å¯è§ */
}
/*åˆ°æ­¤ç»“æŸæµè§ˆå™¨*/
        /* --- CURSOR (Existing) --- */
        #hand-cursor {
            position: absolute; width: 30px; height: 30px;
            border: 2px solid var(--star-glow); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 2001;
            display: none; box-shadow: 0 0 20px var(--star-glow);
            transition: width 0.1s, height 0.1s, border-color 0.1s;
        }
        #hand-cursor.drag { border-color: var(--alert-red); width: 15px; height: 15px; background: rgba(255, 50, 0, 0.3); }
        #hand-cursor.zoom { border-color: #fff; width: 60px; height: 60px; border-style: dashed; }
        
        @keyframes spin { 100% { transform: translate(-50%, -50%) rotate(360deg); } }
        @keyframes pulseBar { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; box-shadow: 0 0 15px var(--star-glow); } }
    </style>
</head>
<body>

<video id="cam-feed" playsinline autoplay muted></video>
<canvas id="hand-canvas"></canvas>
<div id="vignette"></div>
<div id="hand-cursor"></div>

<div id="boot-screen">
            <button class="boot-btn" id="start-btn" onclick="systemBoot()">INITIATE STARSHIP HMI</button>
    <div id="boot-log" style="margin-top:20px; font-size:15px; color:var(--star-blue); display:none; text-align:center;">
        LOADING CORE...
    </div>
</div>
<div id="browser-trigger-area">
    <img id="browser-logo" src="logobrowser.png" alt="Browser" title="Open Embedded Browser" />
</div>
<div id="ui-layer">
    <div class="top-bar">
        <div class="hud-tag">FLIGHT CONTROL</div>
        <div class="hud-tag" id="sys-clock">00:00:00</div>
        <div class="hud-tag">VOICE: <span id="voice-status" style="color:var(--alert-red)">OFFLINE</span></div>
    </div>

    <div class="left-panel">
        <div class="stat-group">
            <div class="label-text">POWER CORE STATUS</div>
            <div class="bar-frame"><div class="bar-fill active" style="width:95%"></div></div>
        </div>
        
        <div class="box-container">
            <div class="label-text">HAND TRACKING</div>
            <div id="hand-log" style="font-size:15px; color:#fff; margin-top:5px;">INITIALIZING...</div>
        </div>

        <div class="box-container">
            <div class="label-text" style="display:flex; justify-content:space-between;">
                <span>SYSTEM DIAGNOSTICS</span>
                <span style="color:var(--star-glow)">ONLINE</span>
            </div>
            <div style="margin-top:5px; display:flex; gap:5px; align-items:center;">
                <span style="font-size:11px; color:var(--star-blue)">CPU</span>
                <div class="bar-frame" style="width:60px;"><div id="cpu-bar" class="bar-fill" style="width:40%; box-shadow:none;"></div></div>
                <span style="font-size:11px; color:var(--star-blue)">NET</span>
                <div class="bar-frame" style="width:60px;"><div id="net-bar" class="bar-fill" style="width:80%; box-shadow:none;"></div></div>
            </div>
            <div id="hex-dump"></div>
        </div>

        <div class="box-container" style="min-height: 80px;">
            <div class="label-text">EXTERNAL SENSORS</div>
            <div id="weather-box" style="margin-top:5px; opacity: 0.5;">
                <div id="weather-display" class="weather-val">--Â°</div>
                <div id="weather-desc" class="weather-sub">STANDBY</div>
            </div>
        </div>
        
    </div>
    
    <div class="right-panel" id="radar-panel">
        <div id="radar-housing">
            <button id="exit-fullscreen-btn" onclick="toggleFullscreen(false)">EXIT</button>
            <div id="radar-sweep"></div>
            <div id="map-layer">
                <div id="map"></div>
            </div>
            <div style="position:absolute; bottom:20px; left:0; width:100%; text-align:center; font-size:14px; letter-spacing:3px; text-shadow:0 0 5px var(--star-blue); pointer-events: none; color: var(--star-blue);">
                GEOSPATIAL FEED
            </div>
        </div>
    </div>
    <!--æˆ‘çš„æµè§ˆå™¨-->
    <div id="browser-widget" class="work-widget" style="display: none;">
    
    <div class="widget-header" id="browser-drag-handle">
        <span><i class="fas fa-globe"></i> NOVELLA WEB INTERFACE</span>
        <i class="fas fa-times widget-close" onclick="toggleBrowser(false)"></i>
    </div>
    
    <div id="web-controls-bar">
        <input type="text" id="web-address-bar" placeholder="Enter URL or search keyword..." />
        
        <button id="web-go-btn" onclick="loadURL(document.getElementById('web-address-bar').value)">GO</button>
    </div> 
    
   <iframe 
   id="embedded-iframe" 
   src="about:blank"
   
   /* å…³é”®ä¿®æ­£ï¼šsandbox å±æ€§åº”ç¡®ä¿åŒ…å« allow-popupsï¼Œä»¥ä¾¿å…è®¸æ–°çª—å£å¼¹å‡º */
   sandbox="allow-scripts allow-same-origin allow-popups allow-forms allow-top-navigation"
   
   ></iframe>
    
</div>
  <!--æˆ‘çš„æµè§ˆå™¨-->
    <div id="calendar-widget" class="work-widget">
        <div class="widget-header">
            <span>FLIGHT CALENDAR - DEC 2025</span>
            <i class="fas fa-times widget-close" onclick="toggleWidget('calendar')"></i>
        </div>
        <div id="calendar-body">
            <div class="day-header">SUN</div><div class="day-header">MON</div><div class="day-header">TUE</div>
            <div class="day-header">WED</div><div class="day-header">THU</div><div class="day-header">FRI</div>
            <div class="day-header">SAT</div>
            </div>
    </div>

     <div id="reminder-widget" class="work-widget" style="width: 350px; left: 70%; top: 30%;">
        <div class="widget-header">
            <span>MISSION REMINDERS</span>
            <i class="fas fa-times widget-close" onclick="toggleWidget('reminder')"></i>
        </div>
        <div id="reminder-list-container">
            <ul id="reminder-list">
                <li class="no-reminders">No scheduled reminders.</li>
            </ul>
        </div>
        <div id="manual-reminder-input" style="display: none; margin-top: 10px;">
            <input type="text" id="new-reminder-title" placeholder="Reminder Title..." class="reminder-input-field">
            <input type="text" id="new-reminder-time" placeholder="Time (e.g., 10:30, tomorrow 8 pm)..." class="reminder-input-field">
            <button class="add-reminder-btn" onclick="manualAddReminder()">ADD MANUALLY</button>
        </div>
        <button id="toggle-manual-btn" class="add-reminder-btn" onclick="toggleManualReminderInput(true)">ADD NEW TIMED REMINDER</button>
    </div>



 <div id="music-widget" class="work-widget" style="width: 450px; left: 50%; top: 50%;">
        <div class="widget-header">
            <span>ATMOS MUSIC PLAYER</span>
            <i class="fas fa-times widget-close" onclick="toggleWidget('music')"></i>
        </div>
        
        <div id="music-player">
            <div id="track-name">Pulsar Rendezvous</div>
            <div id="artist-name">Cygnus X-1</div>
            
            <audio id="audio-player" preload="auto" src=""></audio>
            
            <div class="seek-controls">
                <i class="fas fa-history seek-btn music-btn" onclick="seekMusic(-10)" title="åé€€ 10 ç§’"></i>
                <i class="fas fa-forward seek-btn music-btn" onclick="seekMusic(10)" title="å‰è¿› 10 ç§’"></i>
            </div>

            <div class="music-controls">
                <i class="fas fa-random music-btn" id="shuffle-btn" onclick="setPlayMode('shuffle')" title="éšæœºæ’­æ”¾"></i>
                <i class="fas fa-step-backward music-btn" onclick="skipTrack('prev')" title="ä¸Šä¸€æ›²"></i>
                <i id="play-btn" class="fas fa-play music-btn" onclick="toggleMusic()" title="æ’­æ”¾/æš‚åœ"></i> 
                <i class="fas fa-step-forward music-btn" onclick="skipTrack('next')" title="ä¸‹ä¸€æ›²"></i>
                <i class="fas fa-redo-alt music-btn" id="repeat-btn" onclick="setPlayMode('repeat')" title="åˆ—è¡¨å¾ªç¯/å•æ›²å¾ªç¯"></i>
            </div>
            
            <div id="subtitle-area">
                <div id="current-subtitle">[Waiting for track data...]</div>
            </div>
            
            <div class="learning-controls">
                <button class="learn-btn" onclick="speakCurrentSentence()" title="å¤è¯»å½“å‰å¥å­">å•å¥é‡è¯»</button>
                <button class="learn-btn" onclick="speakWordByWord()" title="é€è¯å¤è¯»">å•è¯é‡è¯»</button>
                <button class="learn-btn" onclick="stopSpeech()" title="åœæ­¢è¯­éŸ³å¤è¯»/é‡æ’­">åœæ­¢/é‡æ’­</button>
            </div>


            <div id="playlist-section">
                <div class="label-text">PLAYLIST: <span id="playlist-count">1</span> TRACKS</div>
                <ul id="playlist-list">
                    <li class="no-reminders">Use the buttons below to add tracks.</li>
                </ul>
                <input type="file" id="folder-input" accept="audio/*" multiple webkitdirectory directory>
                <button class="add-reminder-btn" onclick="document.getElementById('folder-input').click()">å¯¼å…¥æ–‡ä»¶/æ–‡ä»¶å¤¹</button>
            </div>
        </div>
    </div>


    <div class="bottom-console">
        <div class="label-text" style="border-bottom:1px solid var(--star-blue); margin-bottom:5px;">SYSTEM LOG (Nova Log)</div>
        <div id="log-feed">
            <div>[SYS] READY.</div>
        </div>
    </div>

    <div id="tool-bar">
        <div class="tool-btn" data-tool="calendar" onclick="toggleWidget('calendar')"><i class="fas fa-calendar-alt"></i><br><span style="font-size:8px;">CALENDAR</span></div>
        <div class="tool-btn" data-tool="reminder" onclick="toggleWidget('reminder')"><i class="fas fa-bell"></i><br><span style="font-size:8px;">REMINDER</span></div>
        <div class="tool-btn" data-tool="music" onclick="toggleWidget('music')"><i class="fas fa-music"></i><br><span style="font-size:8px;">MUSIC</span></div>
        <div class="tool-btn" data-tool="map" id="map-tool-btn" onclick="toggleFullscreen()"><i class="fas fa-expand-alt"></i><i class="fas fa-compress-alt"></i><br><span style="font-size:8px;">RADAR</span></div>
    </div>

</div>


    <div class="bottom-console">
        <div class="label-text" style="border-bottom:1px solid var(--star-blue); margin-bottom:5px;">SYSTEM LOG</div>
        <div id="log-feed">
            <div>[SYS] READY.</div>
        </div>
    </div>

    <div id="tool-bar">
        <div class="tool-btn" data-tool="calendar" onclick="toggleWidget('calendar')"><i class="fas fa-calendar-alt"></i><br><span style="font-size:8px;">CALENDAR</span></div>
        <div class="tool-btn" data-tool="reminder" onclick="toggleWidget('reminder')"><i class="fas fa-bell"></i><br><span style="font-size:8px;">REMINDER</span></div>
        <div class="tool-btn" data-tool="music" onclick="toggleWidget('music')"><i class="fas fa-music"></i><br><span style="font-size:8px;">MUSIC</span></div>
        <div class="tool-btn" data-tool="map" id="map-tool-btn" onclick="toggleFullscreen()"><i class="fas fa-expand-alt"></i><i class="fas fa-compress-alt"></i><br><span style="font-size:8px;">RADAR</span></div>
    </div>

</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<script>
    // --- CONFIG ---
 const STATE = {
        booted: false,
        fullscreen: false,
        speaking: false,
        map: null,
        detailedMode: false,
        zoomLock: 0,
        defaultLoc: [39.9042, 116.4074],
        recognition: null,
        activeWidget: null, // å½“å‰æ´»åŠ¨çš„å°éƒ¨ä»¶
        // --- éŸ³ä¹æ’­æ”¾å™¨æ ¸å¿ƒ STATE ä¿®æ­£ä¸é›†æˆ ---
        musicPlaying: false, // éŸ³ä¹æ’­æ”¾çŠ¶æ€
        // ä¿®æ­£ï¼šåœ¨ mainAppInit ä¸­è®¾ç½® audioPlayerï¼Œç°åœ¨åˆå§‹åŒ–ä¸º null
        audioPlayer: null, 
        playlists: [
            // å…³é”®æ–°å¢ï¼šå­˜å‚¨æ‰€æœ‰æ›²ç›®çš„æ ¸å¿ƒæ•°ç»„
            { id: 0, name: "Default System Tracks", tracks: [] } 
        ], 
        trackIdCounter: 1, // å…³é”®æ–°å¢ï¼šç¡®ä¿ ID è®¡æ•°å™¨å­˜åœ¨
        currentTrack: null, // å½“å‰æ’­æ”¾çš„æ›²ç›®å¯¹è±¡
        playMode: 'list', // æ’­æ”¾æ¨¡å¼ ('list', 'shuffle', 'repeat')
        expandedPlaylists: new Set([0]), // è®°å½•å“ªä¸ªæ’­æ”¾åˆ—è¡¨æ˜¯å±•å¼€çš„
        // ----------------------------------------
        
      reminders: [], 
    reminderIdCounter: 1, // <--- å…³é”®æ–°å¢ï¼šç¡®ä¿è®¡æ•°å™¨åœ¨å¯åŠ¨æ—¶å¯ç”¨
    DEFAULT_MUSIC_LINK: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3",
};
 

    // === Dify å·¥ä½œæµé…ç½®ï¼ˆè¯·æ›¿æ¢æˆä½ è‡ªå·±çš„ Keyï¼‰ ===
    const DIFY_CONFIG = {
        endpoint: "https://api.dify.ai/v1/workflows/run",
        // æ³¨æ„ï¼šè¿™é‡Œä»ç„¶ä½¿ç”¨ä½ æä¾›çš„ Key ä½œä¸ºç¤ºä¾‹ï¼Œè¯·åœ¨å®é™…ä½¿ç”¨æ—¶ç¡®ä¿å…¶æœ‰æ•ˆæ€§
        apiKey: "app-lYOYMvRg12X0Ut78gOWDFvhi",
        inputKey: "query",
        outputKey: "reply"
    };

    const CITIES = {
        "shanghai": [31.2304, 121.4737], "beijing": [39.9042, 116.4074], "tokyo": [35.6762, 139.6503],
        "new york": [40.7128, -74.0060], "london": [51.5074, -0.1278], "paris": [48.8566, 2.3522],
        "starbase": [29.8781, 121.5492] // Added Starbase, TX
    };

    const WMO_CODES = {
        0: "Clear Sky", 1: "Mainly Clear", 2: "Partly Cloudy", 3: "Overcast",
        45: "Fog", 48: "Depositing Rime Fog", 51: "Light Drizzle", 53: "Moderate Drizzle", 55: "Dense Drizzle",
        61: "Slight Rain", 63: "Moderate Rain", 65: "Heavy Rain", 71: "Slight Snow", 73: "Moderate Snow",
        75: "Heavy Snow", 95: "Thunderstorm", 96: "Thunderstorm with Hail", 99: "Heavy Hailstorm"
    };
// å…¨å±€å˜é‡ï¼šå¿…é¡»åœ¨å‡½æ•°å¤–éƒ¨å®šä¹‰ï¼
   let isBrowserDragging = false;
        let dragElement = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastBrowserToggleTime = 0;
        const TOGGLE_DEBOUNCE_MS = 700;

    // --- æµè§ˆå™¨æ§åˆ¶å‡½æ•° ---
    /**
     * åˆ‡æ¢æµè§ˆå™¨æµ®çª—çš„æ˜¾ç¤ºçŠ¶æ€ã€‚
     * @param {boolean} show - å¼ºåˆ¶æ˜¾ç¤º (true) æˆ–å…³é—­ (false)ã€‚
     */
    function toggleBrowser(show) {
        const browserWidget = document.getElementById('browser-widget');
        const browserLogo = document.getElementById('browser-logo');
        // æ£€æŸ¥å½“å‰çŠ¶æ€æ¥å†³å®šæ˜¯æ‰“å¼€è¿˜æ˜¯å…³é—­
        const shouldOpen = (typeof show === 'boolean') ? show : (browserWidget.style.display === 'none' || !browserWidget.style.display);
        
        if (shouldOpen) {
            browserWidget.style.display = 'flex';
            // å¦‚æœ iframe æ˜¯ç©ºçš„ï¼ŒåŠ è½½é»˜è®¤ URL
            const iframe = document.getElementById('embedded-iframe');
            if (iframe.src === 'about:blank' || !iframe.src) {
                 loadURL('https://en.wikipedia.org/'); 
            } 
            browserLogo.classList.add('active'); 
            if (typeof sysLog === 'function') sysLog("WEB INTERFACE ONLINE", "SYS");
        } else {
            browserWidget.style.display = 'none';
            browserLogo.classList.remove('active'); 
            if (typeof sysLog === 'function') sysLog("WEB INTERFACE OFFLINE", "SYS");
        }
    }

   /**
 * åŠ è½½ URL åˆ° iframe ä¸­ã€‚å¯¹äºå¤–éƒ¨ç½‘ç«™ï¼Œä½¿ç”¨ window.open() åœ¨æ–°çª—å£ä¸­æ‰“å¼€ï¼Œ
 * ä»¥ç»•è¿‡ X-Frame-Options/CSP é™åˆ¶ã€‚
 * @param {string} url - ç”¨æˆ·è¾“å…¥çš„ URLã€‚
 */
function loadURL(url) {
    let targetUrl = url.trim();
    const iframe = document.getElementById('embedded-iframe');
    const addressBar = document.getElementById('web-address-bar');

    // 1. URL æ ¼å¼ä¿®æ­£å’Œæœç´¢è½¬æ¢
    if (!targetUrl.startsWith('http://') && !targetUrl.startsWith('https://') && targetUrl !== 'about:blank') {
        // å¦‚æœè¾“å…¥åŒ…å«ç©ºæ ¼æˆ–ä¸æ˜¯ä¸€ä¸ªæ˜æ˜¾çš„åŸŸåï¼ˆå¦‚å…³é”®å­—ï¼‰ï¼Œåˆ™è§†ä¸ºæœç´¢
        if (targetUrl.includes(' ') || !targetUrl.includes('.')) { 
             // è½¬æ¢ä¸º DuckDuckGo æœç´¢é“¾æ¥
             targetUrl = `https://duckduckgo.com/?q=${encodeURIComponent(targetUrl)}`;
        } else {
            // è§†ä¸ºåŸŸåï¼Œæ·»åŠ  https://
            targetUrl = 'https://' + targetUrl;
        }
    }
    
    // 2. åˆ¤æ–­æ˜¯å¦ä¸ºå¤–éƒ¨é“¾æ¥
    const isExternalWeb = targetUrl.startsWith('http') && targetUrl !== 'about:blank';
    
    if (isExternalWeb) {
        // ã€æ ¸å¿ƒä¿®æ­£ã€‘ï¼šä½¿ç”¨æ–°çª—å£æ‰“å¼€å¤–éƒ¨é“¾æ¥
        // åªæœ‰å½“ window.open() ç”±ç”¨æˆ·ç›´æ¥æ“ä½œè§¦å‘æ—¶ï¼Œæ‰ä¸ä¼šè¢«æµè§ˆå™¨é˜»æ­¢ã€‚
        window.open(targetUrl, '_blank');
        
        // å¯é€‰ï¼šé‡ç½® iframe å†…å®¹ï¼Œé¿å…æ˜¾ç¤ºâ€œæ‹’ç»è¿æ¥â€çš„é”™è¯¯
        if (iframe && iframe.src !== 'about:blank') {
             iframe.src = 'about:blank'; 
        }

        if (typeof sysLog === 'function') {
            sysLog(`WEB: External link opened in new window: ${targetUrl.substring(0, 50)}...`, "DAT");
        }
        
    } else {
        // 3. å¤„ç†å†…éƒ¨æˆ–æœ¬åœ°é“¾æ¥ (å¦‚ about:blank)
        if (iframe) {
             iframe.src = targetUrl;
        }
        if (typeof sysLog === 'function') {
            sysLog(`WEB: Loading internal content: ${targetUrl}`, "DAT");
        }
    }

    // 4. æ›´æ–°åœ°å€æ æ˜¾ç¤º
    if (addressBar) {
        addressBar.value = targetUrl;
    }
}
    // --- WIDGET FUNCTIONS ---

    function toggleWidget(widgetName, enable = null) {
        const widgetElement = document.getElementById(widgetName + '-widget');
        const toolbarButton = document.querySelector(`#tool-bar .tool-btn[data-tool="${widgetName}"]`);

        if (!widgetElement) return;

        let shouldOpen = (enable !== null) ? enable : (STATE.activeWidget !== widgetName);

        // 1. Close ALL widgets and reset toolbar states
        document.querySelectorAll('.work-widget').forEach(w => w.style.display = 'none');
        document.querySelectorAll(`#tool-bar .tool-btn`).forEach(b => {
             if (b.dataset.tool !== 'map') b.classList.remove('active');
        });
        STATE.activeWidget = null;

        // 2. Open the requested widget
        if (shouldOpen) {
            widgetElement.style.display = 'flex';
            toolbarButton.classList.add('active');
            STATE.activeWidget = widgetName;
            sysLog(`WORKSTATION: ${widgetName.toUpperCase()} ONLINE`, "SYS");
        }
    }

    // --- REMINDER FUNCTIONS ---

 function parseTimeInput(input) {
    const now = new Date();
    const inputTrimmed = input.trim();

    // 1. **ä¼˜å…ˆè§£æ YYYYMMDDHHMM æ ¼å¼ (12ä½æ•°å­—)**
    const dateMatch = inputTrimmed.match(/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})$/);
    
    if (dateMatch) {
        const [, yearStr, monthStr, dayStr, hourStr, minuteStr] = dateMatch;
        
        // å°è¯•åˆ›å»ºæ—¥æœŸå¯¹è±¡
        const targetDate = new Date(
            parseInt(yearStr), 
            parseInt(monthStr) - 1, // JSæœˆä»½æ˜¯ 0-indexed
            parseInt(dayStr), 
            parseInt(hourStr), 
            parseInt(minuteStr), 
            0, 
            0
        );

        // --- æ—¥æœŸæœ‰æ•ˆæ€§éªŒè¯ ---
        const inputMonth = parseInt(monthStr);
        const inputDay = parseInt(dayStr);
        
        if (
            isNaN(targetDate.getTime()) ||
            targetDate.getFullYear() !== parseInt(yearStr) ||
            targetDate.getMonth() + 1 !== inputMonth || // æœˆä»½éªŒè¯ï¼Œé˜²æ­¢æ»šè½¬
            targetDate.getDate() !== inputDay // æ—¥æœŸéªŒè¯ï¼Œé˜²æ­¢æ»šè½¬ï¼ˆå¦‚ 2æœˆ30æ—¥ï¼‰
        ) {
             sysLog(`Invalid date/time values: ${inputTrimmed}.`, "ALERT");
            return null;
        }

        // æ£€æŸ¥è§£æå‡ºçš„æ—¶é—´æ˜¯å¦åœ¨è¿‡å»
        if (targetDate.getTime() <= now.getTime()) {
            sysLog(`Date/Time ${inputTrimmed} is in the past.`, "ALERT");
            return null;
        }

        return targetDate.getTime();
    }

    // 2. **å›é€€åˆ°ç°æœ‰çš„ç›¸å¯¹æ—¶é—´/ç®€å•æ—¶é—´è§£æé€»è¾‘**
    let targetDate = new Date(now.getTime()); 
    let processedInput = inputTrimmed;

    // æ£€æŸ¥ "tomorrow" æˆ– "æ˜å¤©"
    const wasTomorrowSpecified = /(tomorrow|æ˜å¤©)/i.test(processedInput);
    if (wasTomorrowSpecified) {
        targetDate.setDate(now.getDate() + 1);
        processedInput = processedInput.replace(/(tomorrow|æ˜å¤©)/i, '');
    }
    
    // æ¸…ç†æ—¶é—´åˆ†éš”ç¬¦
    processedInput = processedInput.replace(/at |@ /i, '').trim();

    // åŒ¹é… HH(:MM)? (AM|PM)? æ ¼å¼
    let timeMatch = processedInput.match(/(\d{1,2})(:(\d{2}))?\s*(a\.?m\.?|p\.?m\.?)?/i);
    
    if (!timeMatch) {
        // æ—¢ä¸æ˜¯ YYYYMMDDHHMM æ ¼å¼ï¼Œåˆæ²¡æœ‰åŒ¹é…åˆ°ç®€å•æ—¶é—´æ ¼å¼
        return null; 
    }

    // è§£æ HH:MM AM/PM
    let hours = parseInt(timeMatch[1]);
    let minutes = timeMatch[3] ? parseInt(timeMatch[3]) : 0;
    let ampm = timeMatch[4] ? timeMatch[4].toLowerCase().replace(/\./g, '') : null;

    if (ampm === 'pm' && hours < 12) {
        hours += 12;
    } else if (ampm === 'am' && hours === 12) {
        hours = 0; 
    }
    
    // è®¾ç½®æ—¶é—´åˆ°ç›®æ ‡æ—¥æœŸ
    targetDate.setHours(hours, minutes, 0, 0); 

    // å¦‚æœæ²¡æœ‰æ˜ç¡®æŒ‡å®šâ€œæ˜å¤©â€ AND è®¡ç®—å‡ºçš„æ—¶é—´ç‚¹åœ¨è¿‡å»ï¼Œåˆ™æ¨è¿Ÿåˆ°æ˜å¤©
    if (!wasTomorrowSpecified && targetDate.getTime() <= now.getTime()) {
        targetDate.setDate(targetDate.getDate() + 1);
        sysLog(`Time in the past, scheduling for tomorrow.`, "DAT");
    }

    return targetDate.getTime();
}

function saveReminders() {
    const serializableReminders = STATE.reminders.map(r => ({
        id: r.id,
        title: r.title,
        timestamp: r.timestamp,
        completed: r.completed
    }));
    localStorage.setItem('starship_reminders', JSON.stringify(serializableReminders));
}

function loadReminders() {
    const stored = localStorage.getItem('starship_reminders');
    if (stored) {
        try {
            const loaded = JSON.parse(stored);
            STATE.reminders = loaded.map(r => ({ ...r, timeoutId: null })); 
            
            const maxId = STATE.reminders.reduce((max, r) => Math.max(max, r.id || 0), 0);
            STATE.reminderIdCounter = maxId + 1;
            
        } catch (e) {
            console.error("Failed to parse stored reminders.", e);
            STATE.reminders = [];
        }
    }
    renderReminders();
    scheduleAlerts(); 
}

function scheduleAlerts() {
    STATE.reminders.forEach(r => {
        if (r.timeoutId) clearTimeout(r.timeoutId);
    });

    STATE.reminders.filter(r => !r.completed).forEach(r => {
        const timeUntil = r.timestamp - Date.now();
        if (timeUntil > 0) {
            r.timeoutId = setTimeout(() => {
                alert(`ğŸš¨ MISSION ALERT: ${r.title} is now due!`);
                sysLog(`REMINDER: ${r.title}`, "ALERT");
                r.completed = true; // Mark as completed after alert
                renderReminders();
                saveReminders();
            }, timeUntil);
        } else {
            // If the reminder is in the past, but not completed, alert immediately and mark complete
            if (!r.completed) {
                alert(`ğŸš¨ MISSED ALERT: ${r.title} was due at ${new Date(r.timestamp).toLocaleTimeString()}`);
                sysLog(`MISSED REMINDER: ${r.title}`, "ALERT");
                r.completed = true;
                renderReminders();
                saveReminders();
            }
        }
    });
}

function renderReminders() {
    const list = document.getElementById('reminder-list');
    // **ç¡®ä¿ list å…ƒç´ å­˜åœ¨**
    if (!list) {
        console.error("DOM Error: #reminder-list element not found.");
        // æ³¨æ„ï¼šè¿™é‡Œä¿ç•™äº† sysLogï¼Œè¯·ç¡®ä¿ sysLog å‡½æ•°å­˜åœ¨äºæ‚¨çš„ä»£ç ä¸­
        sysLog("ERROR: Reminder list DOM missing.", "ALERT"); 
        return;
    }
    
    list.innerHTML = '';
    if (STATE.reminders.length === 0) {
        list.innerHTML = '<li class="no-reminders">No scheduled reminders.</li>';
        return;
    }

    STATE.reminders.sort((a, b) => a.timestamp - b.timestamp);

    STATE.reminders.forEach(r => {
        const li = document.createElement('li');
        li.className = 'reminder-item';
        const date = new Date(r.timestamp);
        const formattedDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const formattedTime = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

        li.innerHTML = `
            <div class="reminder-title" style="color:${r.completed ? 'rgba(0, 224, 255, 0.4)' : '#fff'}; text-decoration: ${r.completed ? 'line-through' : 'none'};">
                ${r.title} 
                <i class="fas fa-check" style="margin-left:5px; color:${r.completed ? 'var(--star-blue)' : 'transparent'};"></i>
            </div>
            <div class="reminder-schedule">
                ${formattedDate} ${formattedTime}
            </div>
        `;
        
        const deleteBtn = document.createElement('i');
        deleteBtn.className = 'fas fa-trash-alt delete-track-btn';
        deleteBtn.title = 'Delete Reminder';
        deleteBtn.style.alignSelf = 'flex-end';
        deleteBtn.onclick = (e) => {
            e.stopPropagation();
            deleteReminder(r.id);
        };
        li.appendChild(deleteBtn);
        
        li.onclick = () => toggleReminderCompletion(r.id);

        list.appendChild(li);
    });
}

function manualAddReminder() {
    const titleInput = document.getElementById('new-reminder-title');
    const timeInput = document.getElementById('new-reminder-time');

    // **ç¡®ä¿è¾“å…¥æ¡†å…ƒç´ å­˜åœ¨**
    if (!titleInput || !timeInput) {
        sysLog("DOM Error: Reminder input fields missing.", "ALERT");
        return;
    }
    
    const title = titleInput.value.trim();
    const timeText = timeInput.value.trim();

    if (title && timeText) {
        const timestamp = parseTimeInput(timeText);
        if (timestamp) {
            const newReminder = {
                id: STATE.reminderIdCounter++,
                title: title,
                timestamp: timestamp,
                completed: false,
                timeoutId: null
            };
            STATE.reminders.push(newReminder);
            sysLog(`Scheduled reminder: ${title}`, "SYS");
            titleInput.value = '';
            timeInput.value = '';
            toggleManualReminderInput(false);
            renderReminders();
            scheduleAlerts();
            saveReminders();
        } else {
            sysLog(`Invalid time format for reminder.`, "ALERT");
        }
    } else {
        sysLog(`Reminder title and time cannot be empty.`, "ALERT");
    }
}

function toggleManualReminderInput(show) {
    const inputDiv = document.getElementById('manual-reminder-input');
    const toggleBtn = document.getElementById('toggle-manual-btn');
    // **ç¡®ä¿æ§åˆ¶å…ƒç´ å­˜åœ¨**
    if (!inputDiv || !toggleBtn) return; 

    if (show) {
        inputDiv.style.display = 'block';
        toggleBtn.style.display = 'none';
    } else {
        inputDiv.style.display = 'none';
        toggleBtn.style.display = 'block';
    }
}

function toggleReminderCompletion(id) {
    const reminder = STATE.reminders.find(r => r.id === id);
    if (reminder) {
        reminder.completed = !reminder.completed;
        sysLog(`Reminder ID ${id} marked as ${reminder.completed ? 'COMPLETED' : 'PENDING'}`, "SYS");
        renderReminders();
        saveReminders();
        scheduleAlerts();
    }
}

function deleteReminder(id) {
    STATE.reminders = STATE.reminders.filter(r => r.id !== id);
    sysLog(`Reminder ID ${id} deleted.`, "SYS");
    renderReminders();
    saveReminders();
    scheduleAlerts(); // Clears timeout if it was scheduled
}
// --- END REMINDER FUNCTIONS ---

/**
 * åˆ‡æ¢æµè§ˆå™¨æµ®çª—çš„æ˜¾ç¤ºçŠ¶æ€ã€‚
 * @param {boolean} show - å¼ºåˆ¶æ˜¾ç¤º (true) æˆ–å…³é—­ (false)ã€‚
 */
function toggleBrowser(show) {
    const browserWidget = document.getElementById('browser-widget');
    const browserLogo = document.getElementById('browser-logo');
    const shouldOpen = (typeof show === 'boolean') ? show : (browserWidget.style.display === 'none' || !browserWidget.style.display);
    
    if (shouldOpen) {
        // æ‰“å¼€æ—¶åŠ è½½é»˜è®¤é¡µé¢
        browserWidget.style.display = 'flex';
        // ç¡®ä¿åœ°å€æ æ˜¾ç¤ºå½“å‰åŠ è½½çš„ URL (å¦‚æœå·²æœ‰)
        const iframe = document.getElementById('embedded-iframe');
        const addressBar = document.getElementById('web-address-bar');
        if (iframe.src === 'about:blank' || !iframe.src) {
             // é»˜è®¤åŠ è½½ä¸€ä¸ªå®‰å…¨ä¸”å…¼å®¹çš„é¡µé¢
             loadURL('https://en.wikipedia.org/wiki/Legal_English'); 
        } else {
             // åœ°å€æ åŒæ­¥æ˜¾ç¤ºå½“å‰ URL
             addressBar.value = iframe.src;
        }
        browserLogo.classList.add('active'); 
        sysLog("WEB INTERFACE ONLINE", "SYS");
    } else {
        browserWidget.style.display = 'none';
        browserLogo.classList.remove('active'); 
        sysLog("WEB INTERFACE OFFLINE", "SYS");
    }
}

/**
 * åŠ è½½æ–°çš„ URL åˆ° iframe ä¸­ï¼Œå¹¶å¤„ç† URL æ ¼å¼ã€‚
 * @param {string} url - ç”¨æˆ·è¾“å…¥çš„ URLã€‚
 */
function loadURL(url) {
    let targetUrl = url.trim();

    // 1. å°è¯•ä¿®æ­£ URL åè®®
    if (!targetUrl.startsWith('http://') && !targetUrl.startsWith('https://') && targetUrl !== 'about:blank') {
        // å°è¯•æ·»åŠ  HTTPS åè®®
        targetUrl = 'https://' + targetUrl;
    }

    // 2. æ›´æ–° iframe
    const iframe = document.getElementById('embedded-iframe');
    iframe.src = targetUrl;
    
    // 3. æ›´æ–°åœ°å€æ æ˜¾ç¤º
    document.getElementById('web-address-bar').value = targetUrl;
    sysLog(`WEB: Loading ${targetUrl.substring(0, 50)}...`, "DAT");
}


// =================================================================
// æ‹–åŠ¨å’Œåœ°å€æ äº‹ä»¶åˆå§‹åŒ–
// =================================================================

function initBrowserControls() {
    const browserLogo = document.getElementById('browser-logo');
    const addressBar = document.getElementById('web-address-bar');
    const dragHandle = document.getElementById('browser-drag-handle');
    const browserWidget = document.getElementById('browser-widget');
    
    // ã€æ–°å¢ã€‘ï¼šè·å– GO æŒ‰é’®å…ƒç´ 
    const goButton = document.getElementById('web-go-btn'); 
    
    // 1. Logo ç‚¹å‡»äº‹ä»¶
    if (browserLogo) {
        browserLogo.addEventListener('click', () => toggleBrowser());
    }

    // 2. åœ°å€æ åŠ è½½äº‹ä»¶ (Enter é”®)
    // ç¡®ä¿ GO æŒ‰é’®å’Œåœ°å€æ éƒ½å­˜åœ¨
    if (addressBar && goButton) { 
        addressBar.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æäº¤è¡Œä¸º
                
                // ã€æ ¸å¿ƒä¿®æ­£ã€‘ï¼šä¸å†ç›´æ¥è°ƒç”¨ loadURLï¼Œè€Œæ˜¯æ¨¡æ‹Ÿç‚¹å‡» GO æŒ‰é’®
                // è¿™å°†ä½¿æµè§ˆå™¨è®¤ä¸º window.open() æ˜¯ç”±ç”¨æˆ·ç›´æ¥æ“ä½œè§¦å‘çš„ã€‚
                goButton.click(); 
                
                addressBar.blur();
            }
        });
    }

    // 3. æµ®çª—æ‹–åŠ¨é€»è¾‘ (é‡ç”¨ widget-header ä¸Šçš„ move å…‰æ ‡)
    if (dragHandle && browserWidget) {
        dragHandle.addEventListener('mousedown', (e) => {
            // é˜»æ­¢ç‚¹å‡»åœ°å€æ ã€GO æŒ‰é’®æˆ–å…³é—­æŒ‰é’®æ—¶è§¦å‘æ‹–åŠ¨
            if (e.target.id === 'web-address-bar' || e.target.id === 'web-go-btn' || e.target.classList.contains('widget-close')) {
                return;
            }
            
            isBrowserDragging = true;
            dragElement = browserWidget;
            
            // è·å–é¼ æ ‡ç‚¹å‡»ä½ç½®ä¸æµ®çª—å·¦ä¸Šè§’çš„ä½ç½®å·®
            dragStartX = e.clientX - browserWidget.offsetLeft;
            dragStartY = e.clientY - browserWidget.offsetTop;
            
            dragHandle.style.cursor = 'grabbing';
            e.preventDefault(); 
        });
    }
}

// 4. å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨ (ä¿æŒä¸å˜ï¼Œå› ä¸ºå®ƒä»¬å¼•ç”¨äº†å…¨å±€å˜é‡)
document.addEventListener('mousemove', (e) => {
    if (!isBrowserDragging || !dragElement) return;

    // è®¡ç®—æ–°çš„ä½ç½®
    const newX = e.clientX - dragStartX;
    const newY = e.clientY - dragStartY;

    // åº”ç”¨ä½ç½®
    dragElement.style.left = newX + 'px';
    dragElement.style.top = newY + 'px';
    
    // ç§»é™¤ transform: translate(-50%, -50%)ï¼Œé¿å…å†²çª
    dragElement.style.transform = 'none';
});

document.addEventListener('mouseup', () => {
    if (isBrowserDragging) {
        isBrowserDragging = false;
        // ç¡®ä¿å…ƒç´ å­˜åœ¨å†ä¿®æ”¹ cursor
        const handle = document.getElementById('browser-drag-handle');
        if (handle) {
            handle.style.cursor = 'move';
        }
        dragElement = null;
    }
});

// 5. ç¡®ä¿åœ¨ç³»ç»Ÿå¯åŠ¨æˆ– DOMContentLoaded ååˆå§‹åŒ–æ§ä»¶
// **æ³¨æ„:** è¯·å°†æ­¤å‡½æ•°è°ƒç”¨æ·»åŠ åˆ°æ‚¨çš„ `systemBoot()` å‡½æ•°æœ«å°¾æˆ–å…¶ä»–åˆé€‚çš„åˆå§‹åŒ–ä½ç½®ã€‚


    // --- MUSIC FUNCTIONS ---

  // ==========================================================
// --- MUSIC PLAYER ENHANCEMENTS (V12 Hierarchy) ---
// ==========================================================
 function initMusicPlayer() {
    // ğŸš¨ å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ audioPlayer æ˜¯å¦å·²æˆåŠŸåŠ è½½ DOM å…ƒç´ 
    if (!STATE.audioPlayer) {
        // å¦‚æœ audioPlayer ä»ä¸º nullï¼Œè®°å½•é”™è¯¯å¹¶å®‰å…¨é€€å‡º
        sysLog("CRITICAL: Audio player DOM element missing. Music functions disabled.", "ALERT");
        return;
    }

    // Add default track
    STATE.playlists[0].tracks.push({ id: STATE.trackIdCounter++, name: "Pulsar Rendezvous", artist: "Cygnus X-1", url: STATE.DEFAULT_MUSIC_LINK });
    
    // Initial setup
    const defaultTrack = STATE.playlists[0].tracks[0];
    STATE.currentTrack = { playlistId: STATE.playlists[0].id, trackId: defaultTrack.id };
    
    // é”™è¯¯è¡Œä¿®æ­£ï¼šç°åœ¨æˆ‘ä»¬ç¡®å®š STATE.audioPlayer ä¸æ˜¯ null
    STATE.audioPlayer.src = defaultTrack.url; // Pre-load source

    // Setup listener for file input (folder import now enabled)
    document.getElementById('folder-input').addEventListener('change', handleFileImport);
    
    // Setup listener for track end
    STATE.audioPlayer.addEventListener('ended', handleTrackEnd);

    updateMusicDisplay(defaultTrack.name, defaultTrack.artist);
    renderPlaylist();
}
    
    /** Imports audio files (including from folders) and adds them to the playlist. (V12 HIERARCHY) */
    function handleFileImport(event) {
        const files = event.target.files;
        if (files.length === 0) return;

        sysLog(`Found ${files.length} file(s) for import. Analyzing hierarchy...`, "DAT");
        
        const importGroups = {}; // { FolderName: [tracks] }
        
        Array.from(files).forEach(file => {
            if (file.type.startsWith('audio/')) {
                const url = URL.createObjectURL(file);
                const path = file.webkitRelativePath; // e.g., "Folder A/Subfolder B/track.mp3"
                
                // æå–ä¸€çº§ç›®å½•åä½œä¸º Playlist åç§°
                const pathParts = path.split('/');
                const playlistName = pathParts.length > 1 ? pathParts[0] : STATE.playlists[0].name; // Use default if no folder

                // æå–äºŒçº§ç›®å½•åä½œä¸º Artist/Album å
                const artist = pathParts.length > 2 ? pathParts[1] : (pathParts.length > 1 ? "Root Import" : "Unknown");
                const trackName = pathParts[pathParts.length - 1]; // Always the filename

                const track = { 
                    id: STATE.trackIdCounter++, 
                    name: trackName, 
                    artist: artist, 
                    url: url 
                };
                
                if (!importGroups[playlistName]) {
                    importGroups[playlistName] = [];
                }
                importGroups[playlistName].push(track);
            }
        });

        let newPlaylistsCount = 0;
        let newTracksCount = 0;
        let firstNewTrack = null;

        for (const name in importGroups) {
            // Find existing playlist or create new one
            let playlist = STATE.playlists.find(p => p.name === name);
            
            if (!playlist) {
                playlist = {
                    id: new Date().getTime() + Math.random(), // Unique ID for the folder/group
                    name: name,
                    tracks: []
                };
                STATE.playlists.push(playlist);
                newPlaylistsCount++;
            }
            
            // Add new tracks to the playlist
            importGroups[name].forEach(track => {
                // Simple check to prevent duplicates if importing the same file list multiple times
                if (!playlist.tracks.find(t => t.url === track.url)) {
                    playlist.tracks.push(track);
                    newTracksCount++;
                    if (!firstNewTrack) firstNewTrack = track;
                }
            });
            
            STATE.expandedPlaylists.add(playlist.id); // Auto-expand newly imported folder
        }

        if (newTracksCount > 0) {
            sysLog(`Imported ${newTracksCount} tracks into ${newPlaylistsCount} new playlist folders.`, "SYS");
            renderPlaylist();
            // If nothing was playing, load the first new track and start playing
            if (!STATE.currentTrack && firstNewTrack) {
                const playlist = STATE.playlists.find(p => p.tracks.includes(firstNewTrack));
                loadTrack(playlist.id, firstNewTrack.id);
                toggleMusic(true);
            }
        } else {
            speak("No valid audio files or no new files found.");
        }
        event.target.value = null; 
    }

    /** Toggles the expansion state of a playlist group. */
    function togglePlaylistExpand(playlistId) {
        if (STATE.expandedPlaylists.has(playlistId)) {
            STATE.expandedPlaylists.delete(playlistId);
        } else {
            STATE.expandedPlaylists.add(playlistId);
        }
        renderPlaylist();
    }
    
    /** Finds a track by its ID and returns its group and index. */
    function findTrackById(trackId) {
        for (const playlist of STATE.playlists) {
            const trackIndex = playlist.tracks.findIndex(t => t.id === trackId);
            if (trackIndex !== -1) {
                return { playlist, trackIndex, track: playlist.tracks[trackIndex] };
            }
        }
        return null;
    }

    /** Renders the playlist in the widget with hierarchy. */
    function renderPlaylist() {
        const ul = document.getElementById('playlist-list');
        ul.innerHTML = '';
        
        // Calculate total track count
        const totalTracks = STATE.playlists.reduce((sum, p) => sum + p.tracks.length, 0);
        document.getElementById('playlist-count').innerText = totalTracks;

        if (totalTracks === 0) {
            ul.innerHTML = '<li class="no-reminders">Use the buttons below to add tracks.</li>';
            return;
        }

        STATE.playlists.forEach((playlist) => {
            if (playlist.tracks.length === 0) return;

            // --- Playlist Group Header ---
            const headerLi = document.createElement('li');
            headerLi.className = 'playlist-group-header';
            
            const isExpanded = STATE.expandedPlaylists.has(playlist.id);
            const iconClass = isExpanded ? 'fa-folder-open' : 'fa-folder';

            headerLi.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center; width:100%; padding: 5px 8px; cursor:pointer;" 
                     onclick="togglePlaylistExpand(${playlist.id})">
                    <span style="font-weight:bold; color:var(--star-glow);">
                        <i class="fas ${iconClass}" style="margin-right:5px;"></i> ${playlist.name} (${playlist.tracks.length})
                    </span>
                    <i class="fas fa-trash delete-track-btn" onclick="event.stopPropagation(); deletePlaylistGroup(${playlist.id})" title="Remove entire folder"></i>
                </div>
            `;
            ul.appendChild(headerLi);

            // --- Playlist Tracks ---
            if (isExpanded) {
                playlist.tracks.forEach((track, index) => {
                    const li = document.createElement('li');
                    li.className = 'playlist-item';
                    
                    const isCurrent = STATE.currentTrack && STATE.currentTrack.trackId === track.id;
                    if (isCurrent) {
                        li.classList.add('current');
                    }
                    
                    const name = track.name.length > 30 ? track.name.substring(0, 27) + '...' : track.name;
                    
                    li.innerHTML = `
                        <span class="track-info" onclick="loadTrack(${playlist.id}, ${track.id})" title="${track.name} - ${track.artist}">
                            ${index + 1}. ${name} <span style="opacity:0.6;">(${track.artist})</span>
                        </span>
                        <i class="fas fa-trash delete-track-btn" onclick="event.stopPropagation(); deleteTrack(${track.id})" title="Remove track"></i>
                    `;
                    
                    ul.appendChild(li);
                });
            }
        });
        
        // Ensure the current track is visible
        const currentItem = ul.querySelector('.playlist-item.current');
        if (currentItem) {
            currentItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }
    
    /** Removes an entire playlist group (folder). */
    function deletePlaylistGroup(playlistId) {
        if (!confirm("Are you sure you want to delete this entire playlist folder?")) return;

        sysLog(`Attempting to remove playlist group ID ${playlistId}`, "DAT");
        
        const initialLength = STATE.playlists.length;
        
        // Find the group name before deletion for logging
        const groupName = STATE.playlists.find(p => p.id === playlistId)?.name || "Unknown Group";
        
        // Check if currently playing track is in this group
        const isCurrentInGroup = STATE.currentTrack && STATE.playlists.some(p => 
            p.id === playlistId && p.tracks.some(t => t.id === STATE.currentTrack.trackId)
        );

        STATE.playlists = STATE.playlists.filter(p => p.id !== playlistId);
        STATE.expandedPlaylists.delete(playlistId);

        if (STATE.playlists.length < initialLength) {
            sysLog(`Removed playlist folder: ${groupName}.`, "DAT");
            
            if (isCurrentInGroup) {
                // Stop music and try to load the first track of the remaining list
                STATE.audioPlayer.pause();
                STATE.musicPlaying = false;
                STATE.currentTrack = null;
                
                // Find the first track in any remaining playlist
                const firstTrackInRemaining = STATE.playlists.flatMap(p => p.tracks)[0];

                if (firstTrackInRemaining) {
                    const playlist = STATE.playlists.find(p => p.tracks.includes(firstTrackInRemaining));
                    loadTrack(playlist.id, firstTrackInRemaining.id);
                } else {
                    updateMusicDisplay("Playlist Empty", "");
                }
            }
            
            renderPlaylist();
        }
    }

    /** Removes a single track from the playlist by its unique ID. (V12 HIERARCHY) */
    function deleteTrack(trackId) {
        const trackInfo = findTrackById(trackId);
        if (!trackInfo) return;

        // 1. Remove the track from its playlist group
        trackInfo.playlist.tracks.splice(trackInfo.trackIndex, 1);
        sysLog(`Removed track: ${trackInfo.track.name} from group ${trackInfo.playlist.name}`, "DAT");

        // 2. Cleanup empty playlist group
        if (trackInfo.playlist.tracks.length === 0) {
            STATE.playlists = STATE.playlists.filter(p => p.id !== trackInfo.playlist.id);
            STATE.expandedPlaylists.delete(trackInfo.playlist.id);
            sysLog(`Cleaned up empty playlist folder: ${trackInfo.playlist.name}`, "DAT");
        }
        
        // 3. Adjust current playback state if the deleted track was the current one
        if (STATE.currentTrack && STATE.currentTrack.trackId === trackId) {
            STATE.audioPlayer.pause();
            STATE.musicPlaying = false;
            
            // Find the next available track in the flat list
            const allTracks = STATE.playlists.flatMap(p => p.tracks);
            const totalTracks = allTracks.length;

            if (totalTracks > 0) {
                // The track that takes the place of the deleted one (or the first one if all others are gone)
                const nextTrack = allTracks[Math.min(trackInfo.trackIndex, totalTracks - 1)]; 

                if (nextTrack) {
                    const playlist = STATE.playlists.find(p => p.tracks.includes(nextTrack));
                    loadTrack(playlist.id, nextTrack.id);
                    toggleMusic(true);
                }
            } else {
                STATE.currentTrack = null;
                updateMusicDisplay("Playlist Empty", "");
            }
        }
        
        renderPlaylist();
    }

    /** Loads a specific track into the audio player (using playlistId and trackId). */
    function loadTrack(playlistId, trackId) {
        const trackInfo = findTrackById(trackId);
        if (!trackInfo) {
            sysLog("Track not found in playlist.", "ALERT");
            return;
        }
        
        STATE.currentTrack = { playlistId: playlistId, trackId: trackId };
        const track = trackInfo.track;
        
        // Reset subtitle state
        STATE.currentSubtitleIndex = 0;
        clearInterval(STATE.subtitleIntervalId);

        STATE.audioPlayer.src = track.url;
        
        STATE.audioPlayer.load();
        
        // Start playing if currently playing
        if (STATE.musicPlaying) {
            toggleMusic(true);
        } else {
             updateMusicDisplay(track.name, track.artist);
        }
        
        sysLog(`Loaded track: ${track.name}`, "DAT");
        renderPlaylist();
        startSubtitleSimulation();
    }

    /** Updates music display using the current track state. */
    function updateMusicDisplay(name = null, artist = null) {
        const btn = document.getElementById('play-btn');
        
        if (STATE.currentTrack) {
            const trackInfo = findTrackById(STATE.currentTrack.trackId);
            if (trackInfo) {
                document.getElementById('track-name').innerText = trackInfo.track.name;
                document.getElementById('artist-name').innerText = trackInfo.track.artist;
            }
        } else {
             document.getElementById('track-name').innerText = name || "No Track Loaded";
             document.getElementById('artist-name').innerText = artist || "";
        }
        
        if (STATE.musicPlaying) {
            btn.classList.remove('fa-play');
            btn.classList.add('fa-pause');
            btn.classList.add('play');
            startSubtitleSimulation(); 
        } else {
            btn.classList.remove('fa-pause');
            btn.classList.add('fa-play');
            btn.classList.remove('play');
            clearInterval(STATE.subtitleIntervalId);
        }
        
        // Update play mode buttons
        document.getElementById('shuffle-btn').classList.remove('active-mode');
        document.getElementById('repeat-btn').classList.remove('active-mode');

        if (STATE.playMode === 'shuffle') {
            document.getElementById('shuffle-btn').classList.add('active-mode');
            document.getElementById('repeat-btn').title = "åˆ—è¡¨å¾ªç¯/å•æ›²å¾ªç¯";
        } else if (STATE.playMode === 'repeat') {
            document.getElementById('repeat-btn').classList.add('active-mode');
            document.getElementById('repeat-btn').title = "å•æ›²å¾ªç¯";
        } else {
            document.getElementById('repeat-btn').title = "åˆ—è¡¨å¾ªç¯";
        }
    }

    /** Toggles music playback. */
    function toggleMusic(play = null) {
        const totalTracks = STATE.playlists.reduce((sum, p) => sum + p.tracks.length, 0);

        if (totalTracks === 0) {
            speak("The playlist is empty. Please import audio files.");
            return;
        }
        
        if (!STATE.currentTrack) {
            // Load the first available track
            const firstTrack = STATE.playlists.flatMap(p => p.tracks)[0];
            if (firstTrack) {
                const playlist = STATE.playlists.find(p => p.tracks.includes(firstTrack));
                loadTrack(playlist.id, firstTrack.id);
            }
        }
        
        STATE.musicPlaying = (play !== null) ? play : !STATE.musicPlaying;
        
        if (STATE.musicPlaying) {
            STATE.audioPlayer.play().then(() => {
                sysLog("MUSIC: RESUMED", "DAT");
            }).catch(e => {
                sysLog("MUSIC ERROR: Playback blocked. " + e, "ALERT");
                STATE.musicPlaying = false;
                speak("Playback blocked. Please click the play button manually once or check browser settings.");
            });
        } else {
            STATE.audioPlayer.pause();
            sysLog("MUSIC: PAUSED", "DAT");
        }
        updateMusicDisplay();
    }
    
    /** Gets the next track in the flattened list based on play mode. */
    function getNextTrack() {
        // 1. Create a flat list of all tracks
        const allTracks = [];
        STATE.playlists.forEach(p => allTracks.push(...p.tracks));
        const total = allTracks.length;
        
        if (total === 0) return null;

        let currentTrackIndex = -1;
        if (STATE.currentTrack) {
            currentTrackIndex = allTracks.findIndex(t => t.id === STATE.currentTrack.trackId);
        }

        if (currentTrackIndex === -1) {
            return allTracks[0]; 
        }

        if (STATE.playMode === 'repeat') {
            return allTracks[currentTrackIndex]; // Stay on same track
        } else if (STATE.playMode === 'shuffle') {
            let nextIndex;
            do {
                nextIndex = Math.floor(Math.random() * total);
            } while (nextIndex === currentTrackIndex && total > 1);
            return allTracks[nextIndex];
        } else { // 'list'
            const nextIndex = (currentTrackIndex + 1) % total;
            
            // If looping back to the start, only return the first track if the list is long enough OR if looping is implied (we assume list mode loops unless only 1 track)
            if (nextIndex === 0 && total === 1) {
                 return null; // Single track in list mode, don't loop indefinitely
            }
            return allTracks[nextIndex];
        }
    }

    /** Skips track (next or previous). */
    function skipTrack(direction) {
        let nextTrack;
        
        // 1. Get flat list
        const allTracks = STATE.playlists.flatMap(p => p.tracks);
        const total = allTracks.length;
        if (total === 0) return;
        
        let currentTrackIndex = -1;
        if (STATE.currentTrack) {
            currentTrackIndex = allTracks.findIndex(t => t.id === STATE.currentTrack.trackId);
        }
        // If no track loaded, start from the beginning/end
        if (currentTrackIndex === -1) {
             currentTrackIndex = (direction === 'next' ? -1 : 0);
        }

        if (direction === 'next') {
            const nextIndex = (currentTrackIndex + 1) % total;
            nextTrack = allTracks[nextIndex];
        } else if (direction === 'prev') {
            const prevIndex = (currentTrackIndex - 1 + total) % total;
            nextTrack = allTracks[prevIndex];
        }
        
        if (nextTrack) {
            const playlist = STATE.playlists.find(p => p.tracks.includes(nextTrack));
            loadTrack(playlist.id, nextTrack.id);
            toggleMusic(true);
        } else {
            sysLog("Playlist end reached.", "DAT");
            toggleMusic(false);
        }
    }

    /** Handles what happens when a track ends. */
    function handleTrackEnd() {
        sysLog("Track finished. Determining next action...", "DAT");
        
        const nextTrack = getNextTrack();

        if (nextTrack && (!STATE.currentTrack || nextTrack.id !== STATE.currentTrack.trackId)) {
            // Play next track in shuffle/list mode
            const playlist = STATE.playlists.find(p => p.tracks.includes(nextTrack));
            loadTrack(playlist.id, nextTrack.id); 
            toggleMusic(true);
        } else if (STATE.playMode === 'repeat' && nextTrack && STATE.currentTrack && nextTrack.id === STATE.currentTrack.trackId) {
            // Repeat mode: reload and restart the same track
            loadTrack(STATE.currentTrack.playlistId, STATE.currentTrack.trackId);
            toggleMusic(true);
        } else {
            // End of list (list mode without looping)
            toggleMusic(false);
            renderPlaylist();
        }
    }

    /** Sets the play mode and updates UI. */
    function setPlayMode(mode) {
        if (mode === 'shuffle') {
            STATE.playMode = (STATE.playMode === 'shuffle') ? 'list' : 'shuffle';
            sysLog(`Play Mode: ${STATE.playMode === 'shuffle' ? 'Shuffle (éšæœº)' : 'List Loop (åˆ—è¡¨å¾ªç¯)'}`, "SYS");
        } else if (mode === 'repeat') {
            STATE.playMode = (STATE.playMode === 'repeat') ? 'list' : 'repeat';
            sysLog(`Play Mode: ${STATE.playMode === 'repeat' ? 'Repeat Single (å•æ›²å¾ªç¯)' : 'List Loop (åˆ—è¡¨å¾ªç¯)'}`, "SYS");
        }
        updateMusicDisplay();
    }

    /** Seeks forward or backward by 10 seconds. */
    function seekMusic(seconds) {
        if (!STATE.audioPlayer.src) return;
        STATE.audioPlayer.currentTime += seconds;
        sysLog(`Seek: ${seconds > 0 ? '+' : ''}${seconds}s`, "DAT");
    }

    // --- SUBTITLE/LEARNING FUNCTIONS (Simulation) ---
    
    /** Starts interval for simulating subtitle display. */
    function startSubtitleSimulation() {
        clearInterval(STATE.subtitleIntervalId);
        
        if (!STATE.musicPlaying) return; 

        // Reset subtitle index if a new track starts
        if (STATE.currentSubtitleIndex >= STATE.SIMULATED_LYRICS.length) {
             STATE.currentSubtitleIndex = 0;
        }
        
        // Display initial line immediately
        document.getElementById('current-subtitle').textContent = STATE.SIMULATED_LYRICS[STATE.currentSubtitleIndex];
        STATE.currentSubtitleIndex = (STATE.currentSubtitleIndex + 1) % STATE.SIMULATED_LYRICS.length;

        // This simulates a new subtitle line every 4 seconds
        STATE.subtitleIntervalId = setInterval(() => {
            const nextLine = STATE.SIMULATED_LYRICS[STATE.currentSubtitleIndex];
            const subtitleElement = document.getElementById('current-subtitle');
            
            if (nextLine) {
                subtitleElement.textContent = nextLine;
                STATE.currentSubtitleIndex = (STATE.currentSubtitleIndex + 1) % STATE.SIMULATED_LYRICS.length;
            } else {
                // Should not happen with the modulo, but safety reset
                subtitleElement.textContent = "[Simulation Loop Reset]";
                STATE.currentSubtitleIndex = 0; 
            }
        }, 4000); 
    }

    /** Implements 'å•å¥é‡è¯»' (Repeat Sentence). */
    function speakCurrentSentence() {
        stopSpeech();
        const sentence = document.getElementById('current-subtitle').textContent;
        if (sentence.startsWith('[')) {
            speak("Simulation mode active. Cannot repeat track data placeholder.");
            return;
        }
        speak(sentence, 1.0); 
    }

    /** Implements 'å•è¯é‡è¯»' (Repeat Word by Word). */
    function speakWordByWord() {
        if (STATE.speaking) {
            stopSpeech();
            return;
        }
        
        const sentence = document.getElementById('current-subtitle').textContent;
        if (sentence.startsWith('[')) {
            speak("Simulation mode active. Cannot repeat track data placeholder.");
            return;
        }
        
        const cleanSentence = sentence.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");
        const words = cleanSentence.split(/\s+/).filter(word => word.length > 0);
        let wordIndex = 0;
        
        const wasPlaying = STATE.musicPlaying;
        if (wasPlaying) toggleMusic(false);

        // Define readNextWord outside the loop so it can be scheduled recursively
        function readNextWord() {
            if (wordIndex < words.length) {
                const word = words[wordIndex];
                speak(word, 0.7); 
                wordIndex++;
                
                // Use onend for clean scheduling
                speechSynthesis.onend = () => {
                    setTimeout(readNextWord, 1000); 
                    speechSynthesis.onend = null; // Clear handler
                };
            } else {
                sysLog("LEARNING: Word-by-word practice finished.", "SYS");
                if (wasPlaying) toggleMusic(true); 
            }
        }
        
        sysLog("LEARNING: Starting word-by-word practice.", "SYS");
        readNextWord();
    }

    /** Implements 'åœæ­¢/åœæ­¢å¤è¯»' (Stop Speech) and Replay. */
    function stopSpeech() {
        if (speechSynthesis.speaking) {
            speechSynthesis.cancel();
            STATE.speaking = false;
            sysLog("LEARNING: Speech playback cancelled.", "DAT");
            
            // Resume music playback if it was paused for learning
            if (STATE.audioPlayer.paused && STATE.musicPlaying) {
                 STATE.audioPlayer.play();
            }
            return true;
        }
        // If not speaking, treat the button press as a command to re-read the sentence (é‡æ’­)
        else {
            speakCurrentSentence(); 
            return false;
        }
    }




    // --- CALENDAR FUNCTIONS ---

    /** Renders the calendar grid for a specific month (Dec 2025). */
    function renderCalendar() {
        const calendarBody = document.getElementById('calendar-body');
        const today = new Date();
        const currentYear = 2025; // Fixed year for HMI demo
        const currentMonth = 11; // December is 11

        // Clear existing days, keep headers (already in HTML)
        while (calendarBody.children.length > 7) {
            calendarBody.removeChild(calendarBody.lastChild);
        }

        // Get the first day of the month (Dec 1, 2025 is a Monday)
        const firstDayOfMonth = new Date(currentYear, currentMonth, 1).getDay(); // 0 (Sun) to 6 (Sat)
        const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate(); // 31

        // Add padding days for alignment
        for (let i = 0; i < firstDayOfMonth; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.className = 'cal-day';
            calendarBody.appendChild(emptyDay);
        }

        // Add actual days
        for (let day = 1; day <= daysInMonth; day++) {
            const dayElement = document.createElement('div');
            dayElement.className = 'cal-day';
            dayElement.textContent = day;

            // Highlight today (Dec 3rd)
            if (currentYear === today.getFullYear() && currentMonth === today.getMonth() && day === 3) {
                dayElement.classList.add('today');
            }

            // Mock events (e.g., 8, 14, 21)
            if ([8, 14, 21].includes(day)) {
                dayElement.classList.add('event');
            }

            calendarBody.appendChild(dayElement);
        }
    }

   // --- BOOT ---
// --- CORE BOOT FUNCTION ---
async function systemBoot() {
    
    const startButton = document.getElementById('start-btn');
    
    // ã€ç¬¬ 1 é“é˜²çº¿ã€‘: é˜²æ­¢ä»£ç é‡å¤æ‰§è¡Œ (å¦‚ç”¨æˆ·åå¤ç‚¹å‡»)
    if (STATE.booted) {
        if (typeof sysLog === 'function') sysLog("System is already operational.", "SYS");
        if (startButton) startButton.disabled = true; // ç¡®ä¿æŒ‰é’®ä»ç„¶è¢«ç¦ç”¨
        return; 
    }
    
    // ç«‹å³ç¦ç”¨æŒ‰é’®å¹¶æ˜¾ç¤ºæ—¥å¿—ï¼Œé˜²æ­¢ç”¨æˆ·å†æ¬¡ç‚¹å‡»
    if (startButton) {
        startButton.disabled = true; // <--- å…³é”®ä¿®æ­£ï¼šé˜²æ­¢é‡å¤ç‚¹å‡»
        startButton.style.display = 'none';
    }
    
    const log = document.getElementById('boot-log');
    if (log) log.style.display = 'block';

    // =========================================================
    // 1. æ ¸å¿ƒåˆå§‹åŒ– (éé˜»å¡)
    // =========================================================
    STATE.audioPlayer = document.getElementById('audio-player');
    if (STATE.audioPlayer) {
        STATE.audioPlayer.src = STATE.DEFAULT_MUSIC_LINK;
        STATE.audioPlayer.load();
    } else {
        console.error("Audio player element ('audio-player') not found. Music feature disabled.");
    }
    
    renderCalendar();
    renderReminders();
    
    // =========================================================
    // 2. Camera & AI (Await operations)
    // =========================================================
    if (log) log.innerText = "ACCESSING FLIGHT SENSORS...";
    
    try {
        // è¿™é‡Œçš„ await startCamera() åŒ…å«äº† navigator.mediaDevices.getUserMedia()
        await startCamera(); // âœ… å¯åŠ¨æ‘„åƒå¤´
        
        if (log) log.innerText = "LOADING NEURAL NETWORK (MEDIAPIPE)...";
        await initHands(); // âœ… åˆå§‹åŒ– MediaPipe
        
    } catch (e) {
        // æ•è· 'NotReadableError: Device in use' æˆ–æƒé™é”™è¯¯
        if (typeof sysLog === 'function') sysLog(`FATAL ERROR: ${e.name}. Hand tracking disabled.`, "ALERT");
        console.error("Failed to start media stream:", e);
        
        // å³ä½¿æ‘„åƒå¤´å¤±è´¥ï¼Œç³»ç»Ÿä»ç„¶å¯ä»¥ç»§ç»­å¯åŠ¨
    }
    
    // 3. Map & Voice & Core Systems (Non-blocking operations)
    if (log) log.innerText = "INITIALIZING HMI CORE SYSTEMS...";
    initMap();
    startVoiceLoop();
    initClock();
    startStatusSim();
    
    initMusicPlayer(); 
    
    // === æ ¸å¿ƒæµè§ˆå™¨æµ®çª—åˆå§‹åŒ– ===
    initBrowserControls(); // ç¡®ä¿æµè§ˆå™¨äº‹ä»¶ç›‘å¬å™¨è¢«ç»‘å®š
    
    // 4. UI Reveal
    if (log) log.innerText = "SYSTEM BOOT COMPLETE. GOING ONLINE...";
    
    setTimeout(() => {
        const screen = document.getElementById('boot-screen');
        if (screen) {
            screen.style.opacity = '0';
            setTimeout(() => screen.remove(), 1000);
        }

        STATE.booted = true;
        document.getElementById('map-layer').classList.add('active');

        speak("Flight systems and workstation online. H M I initiated.");
        if (typeof sysLog === 'function') sysLog("TRY: 'GO TO STARBASE', 'CHECK WEATHER', OR 'ADD REMINDER TO CHECK FUEL'", "SYS");

        setTimeout(() => { if(STATE.map) STATE.map.invalidateSize(); }, 800);
    }, 1000);
}
// ç¡®ä¿åœ¨è¿™ä¸ª } ä¹‹åï¼Œç›´åˆ°æ–‡ä»¶æœ«å°¾ï¼Œæ²¡æœ‰å…¶ä»–ä»£ç äº†ï¼
    // --- MAP ---
      function initMap() {
        if (STATE.map) STATE.map.remove();
        
        STATE.map = L.map('map', {
            center: STATE.defaultLoc,
            zoom: 13,
            zoomControl: false,
            attributionControl: false,
            dragging: true
        });

        STATE.tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
        }).addTo(STATE.map);

        document.querySelector('#map-layer .leaflet-layer').classList.remove('true-color');

        document.getElementById('radar-sweep').style.pointerEvents = 'none';

        STATE.currentMarker = L.marker(STATE.defaultLoc).addTo(STATE.map)
            .bindPopup("Starship Command Center").openPopup();
            
        STATE.map.invalidateSize(); 
    }

    function toggleColorMode(isTrueColor) {
        const layer = document.querySelector('#map-layer .leaflet-layer');
        if (layer) {
            if (isTrueColor) {
                layer.classList.add('true-color');
                sysLog("RADAR: True color mode engaged.", "SYS");
            } else {
                layer.classList.remove('true-color');
                sysLog("RADAR: HMI tactical filter engaged.", "SYS");
            }
        }
    }

   function toggleFullscreen(enable) {
    const panel = document.getElementById('radar-panel');
    
    // å…³é”®ä¿®æ”¹ï¼šå¦‚æœæ²¡æœ‰ä¼ å…¥ 'enable' å‚æ•°ï¼ˆå³æŒ‰é’®ç‚¹å‡»ï¼‰ï¼Œåˆ™åè½¬å½“å‰çŠ¶æ€
    const shouldEnable = (enable !== undefined && enable !== null) ? enable : !STATE.fullscreen;

    if(shouldEnable) { // å¯ç”¨å…¨å±
        panel.classList.add('fullscreen');
        STATE.fullscreen = true;
        speak("Maximizing display.");
    } else { // ç¦ç”¨å…¨å± (æœ€å°åŒ–)
        panel.classList.remove('fullscreen');
        STATE.fullscreen = false;
        speak("Minimizing display.");
    }
    setTimeout(() => { if(STATE.map) STATE.map.invalidateSize(); }, 500);
}

    function toggleDetailedImage(enable) {
        const tiles = document.querySelectorAll('.leaflet-layer');
        STATE.detailedMode = enable;

        tiles.forEach(t => {
            if(enable) t.classList.add('true-color');
            else t.classList.remove('true-color');
        });

        if(enable) {
            speak("Visual mode: high resolution.");
            sysLog("VISUALS: HIGH RES", "SYS");
        } else {
            speak("Visual mode: tactical overlay.");
            sysLog("VISUALS: TACTICAL", "SYS");
        }
    }

    async function checkWeather() {
        if(!STATE.map) return;
        const center = STATE.map.getCenter();
        const lat = center.lat.toFixed(2);
        const lng = center.lng.toFixed(2);

        sysLog(`SCANNING EXTERNAL ENVIRONMENT...`, "SYS");
        speak("Scanning atmospheric conditions.");

        try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true`;
            const response = await fetch(url);
            const data = await response.json();

            if(data.current_weather) {
                const temp = data.current_weather.temperature;
                const code = data.current_weather.weathercode;
                const desc = WMO_CODES[code] || "Unknown";

                const box = document.getElementById('weather-box');
                const disp = document.getElementById('weather-display');
                const sub = document.getElementById('weather-desc');

                box.style.opacity = '1';
                box.style.border = '1px solid var(--star-blue)';
                disp.innerText = `${temp}Â°C`;
                sub.innerText = desc.toUpperCase();

                speak(`Temperature is ${temp} degrees celsius. Conditions are ${desc}.`);
                sysLog(`TEMP: ${temp}C | ${desc.toUpperCase()}`, "DAT");
            }
        } catch(e) {
            console.error(e);
            speak("Unable to connect to external sensors.");
            sysLog("SENSOR DATA ERROR", "ERR");
        }
    }

    function goToLocation(city) {
        const coords = CITIES[city.toLowerCase()];
        if(coords) {
            speak("Routing map to " + city);
            STATE.map.flyTo(coords, 13, { duration: 2.5 });
            sysLog("NAV: " + city.toUpperCase(), "SYS");
        } else {
            speak("Unknown destination.");
        }
    }

    // --- SIMULATION & UTILS ---
    function startStatusSim() {
        const hex = document.getElementById('hex-dump');
        const cpu = document.getElementById('cpu-bar');
        const net = document.getElementById('net-bar');

        setInterval(() => {
            // Hex dump
            const newHex = Math.random().toString(16).substring(2, 10).toUpperCase();
            hex.innerText = `0x${newHex} :: COMM_BUFF\n` + hex.innerText.substring(0, 100);

            // Random bar movement
            cpu.style.width = Math.floor(Math.random() * 60 + 20) + '%';
            net.style.width = Math.floor(Math.random() * 40 + 50) + '%';
        }, 300);
    }

    function initClock() {
        setInterval(() => {
            const d = new Date();
            document.getElementById('sys-clock').innerText = d.toLocaleTimeString('en-US', {hour12:false});
        }, 1000);
    }

    function sysLog(msg, type) {
        const feed = document.getElementById('log-feed');
        const line = document.createElement('div');
        // Use a new class for JARVIS/AI responses to distinguish them
        line.className = type === 'SYS' ? 'msg-sys' : (type === 'USR' ? 'msg-usr' : 'msg-jarvis');
        line.innerText = `[${type}] ${msg}`;
        feed.prepend(line);
        if(feed.children.length > 5) feed.lastChild.remove();
    }

    // === è°ƒç”¨ Dify å·¥ä½œæµ ===
    async function callDifyWorkflow(userText) {
        if (!DIFY_CONFIG.endpoint || !DIFY_CONFIG.apiKey) {
            console.warn("Dify config missing");
            return null;
        }

        sysLog("ROUTING TO FLIGHT AI...", "SYS");

        try {
            const body = {
                inputs: {
                    [DIFY_CONFIG.inputKey]: userText
                },
                response_mode: "blocking",
                user: "starship-hmi-user"
            };

            const t0 = performance.now();
            const res = await fetch(DIFY_CONFIG.endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${DIFY_CONFIG.apiKey}`
                },
                body: JSON.stringify(body)
            });
            const data = await res.json();
            const t1 = performance.now();

            console.log("Dify workflow raw response:", data);
            sysLog(`AI LATENCY: ${(t1 - t0).toFixed(0)}ms`, "SYS");

            let reply = null;
            if (data && data.data && data.data.outputs) {
                reply = data.data.outputs[DIFY_CONFIG.outputKey];
            }
            if (!reply && data.answer) {
                reply = data.answer;
            }

            if (!reply) {
                sysLog("AI CORE: NO REPLY FIELD", "ERR");
                return null;
            }

            return reply;
        } catch (e) {
            console.error("Dify workflow error:", e);
            sysLog("AI CORE ERROR", "ERR");
            return null;
        }
    }

    // === æŠŠè¯­éŸ³æŒ‡ä»¤äº¤ç»™ Difyï¼Œå¹¶è®©ç³»ç»Ÿè¯´å‡ºæ¥ ===
    async function handleAIWithDify(cmd) {
        const reply = await callDifyWorkflow(cmd);
        if (reply) {
            speak(reply);
        } else {
            speak("I received your command, but the flight AI did not respond.");
        }
    }

    // --- VOICE ---
    function startVoiceLoop() {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if(!SR) { sysLog("VOICE ERROR: API UNAVAILABLE", "ERR"); return; }

        STATE.recognition = new SR();
        STATE.recognition.continuous = false;
        STATE.recognition.lang = 'en-US';
        STATE.recognition.interimResults = false;

        STATE.recognition.onstart = () => {
            const v = document.getElementById('voice-status');
            v.innerText = "LISTENING";
            v.style.color = "var(--star-blue)";
        };

        STATE.recognition.onend = () => {
            const v = document.getElementById('voice-status');
            v.innerText = "STANDBY";
            v.style.color = "var(--alert-red)";
            if (STATE.booted && !STATE.speaking) {
                setTimeout(() => { try { STATE.recognition.start(); } catch(e){} }, 200);
            }
        };

        STATE.recognition.onresult = (event) => {
            processCommand(event.results[0][0].transcript.toLowerCase());
        };

        try { STATE.recognition.start(); } catch(e) {}
    }

    function processCommand(cmd) {
        sysLog(cmd.toUpperCase(), "USR");

        let handled = false;

        // --- NEW WORKSTATION/REMINDER COMMANDS ---
        if(cmd.includes('open calendar') || cmd.includes('show schedule')) { toggleWidget('calendar', true); handled = true; }
        else if(cmd.includes('close calendar') || cmd.includes('hide schedule')) { toggleWidget('calendar', false); handled = true; }
        else if(cmd.includes('open reminders') || cmd.includes('show reminders')) { toggleWidget('reminder', true); handled = true; }
        else if(cmd.includes('close reminders') || cmd.includes('hide reminders')) { toggleWidget('reminder', false); handled = true; }
        else if(cmd.includes('open music') || cmd.includes('show music')) { toggleWidget('music', true); handled = true; }
        else if(cmd.includes('close music') || cmd.includes('hide music')) { toggleWidget('music', false); handled = true; }
        else if(cmd.includes('pause music') || cmd.includes('stop music')) { toggleMusic(false); handled = true; }
        else if(cmd.includes('play music') || cmd.includes('play starbase anthem') || cmd.includes('resume music')) {
            // If the audio element source is empty, set default
            if (!STATE.audioPlayer.src) {
                 STATE.audioPlayer.src = STATE.DEFAULT_MUSIC_LINK;
                 STATE.audioPlayer.load();
            }
            toggleMusic(true);
            handled = true;
        }
        else if(cmd.includes('add reminder to') || cmd.includes('remind me to')) {
            const reminderText = cmd.replace(/^(add reminder to|remind me to)\s+/i, '').trim();
            if(reminderText.length > 5) {
                addReminder(reminderText);
                handled = true;
            } else {
                speak("Please specify the content of the reminder.");
                handled = true;
            }
        }
        else if(cmd.includes('play music link')) {
            const urlMatch = cmd.match(/(http|https):\/\/\S+/i);
            if (urlMatch) {
                loadAndPlayMusic(urlMatch[0]);
                handled = true;
            }
        }


        // --- EXISTING MAP/UTILITY COMMANDS ---
        else if(cmd.includes('open map') || cmd.includes('show display')) {
            document.getElementById('map-layer').classList.add('active');
            speak("Geospatial display online.");
            handled = true;
        }
        else if(cmd.includes('close map') || cmd.includes('hide display')) {
            document.getElementById('map-layer').classList.remove('active');
            speak("Geospatial display offline.");
            handled = true;
        }
        else if(cmd.includes('full screen') || cmd.includes('maximize display')) {
            toggleFullscreen(true);
            handled = true;
        }
        else if(cmd.includes('minimize') || cmd.includes('standard view') || cmd.includes('exit fullscreen')) {
            toggleFullscreen(false);
            handled = true;
        }
        else if((cmd.includes('zoom in') || cmd.includes('increase zoom')) && STATE.map) {
            STATE.map.zoomIn();
            handled = true;
        }
        else if(cmd.includes('zoom out') && STATE.map) {
            STATE.map.zoomOut();
            handled = true;
        }

        else if(cmd.includes('go to') || cmd.includes('route to')) {
            for(let city in CITIES) {
                if(cmd.includes(city)) {
                    goToLocation(city);
                    handled = true;
                    break;
                }
            }
        }
        else if(cmd.includes('reset map') && STATE.map) {
            STATE.map.setView(STATE.defaultLoc, 13);
            speak("Map display reset.");
            handled = true;
        }

        else if(cmd.includes('high resolution') || cmd.includes('true color') || cmd.includes('remove filter')) {
            toggleDetailedImage(true);
            handled = true;
        }
        else if(cmd.includes('tactical view') || cmd.includes('blue mode') || cmd.includes('standard visuals')) {
            toggleDetailedImage(false);
            handled = true;
        }
        else if(cmd.includes('check weather') || cmd.includes('atmospheric report') || cmd.includes('conditions')) {
            checkWeather();
            handled = true;
        }

        // å¦‚æœæ²¡æœ‰å‘½ä¸­ä»»ä½•æœ¬åœ°æŒ‡ä»¤ï¼Œå°±äº¤ç»™ Dify å·¥ä½œæµ
        if (!handled) {
            handleAIWithDify(cmd);
        }
    }

    function speak(text) {
        if(!window.speechSynthesis) return;
        if (STATE.recognition) try { STATE.recognition.stop(); } catch(e){}
        STATE.speaking = true;
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'en-US'; u.pitch = 0.9; u.rate = 1.1;
        u.onend = () => { STATE.speaking = false; if (STATE.booted) try { STATE.recognition.start(); } catch(e){} };
        window.speechSynthesis.speak(u);
        sysLog(text, "FLIGHT AI");
    }

    // --- CAMERA & HANDS --- (No functional changes here)
    let videoElement, canvasElement, canvasCtx;
    let hands;
    let handMode = 'HOVER';
    let lastHandX=0, lastHandY=0, zoomRefY=0;

    async function startCamera() {
        videoElement = document.getElementById('cam-feed');
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
        videoElement.srcObject = stream;
        return new Promise(resolve => videoElement.onloadedmetadata = () => {
            videoElement.play();
            resolve();
        });
    }

    async function initHands() {
        canvasElement = document.getElementById('hand-canvas');
        canvasCtx = canvasElement.getContext('2d');
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandResults);

        const detectFrame = async () => {
            await hands.send({image: videoElement});
            requestAnimationFrame(detectFrame);
        };
        detectFrame();
    }

    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    }

    function drawLine(ctx, lm, i, j) {
        const p1 = lm[i]; const p2 = lm[j];
        ctx.beginPath();
        ctx.moveTo(p1.x * ctx.canvas.width, p1.y * ctx.canvas.height);
        ctx.lineTo(p2.x * ctx.canvas.width, p2.y * ctx.canvas.height);
        ctx.stroke();
    }

    function onHandResults(results) {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        const cursor = document.getElementById('hand-cursor');
        const log = document.getElementById('hand-log');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            log.innerText = "ONLINE";
            log.style.color = "var(--star-blue)";
            cursor.style.display = 'block';

            canvasCtx.strokeStyle = "var(--star-blue)"; // Cyan Skeleton
            canvasCtx.lineWidth = 3;
            for (const lm of results.multiHandLandmarks) {
                // Drawing connections (no change in structure)
                drawLine(canvasCtx, lm, 0, 1); drawLine(canvasCtx, lm, 1, 2); drawLine(canvasCtx, lm, 2, 3); drawLine(canvasCtx, lm, 3, 4);
                drawLine(canvasCtx, lm, 0, 5); drawLine(canvasCtx, lm, 5, 6); drawLine(canvasCtx, lm, 6, 7); drawLine(canvasCtx, lm, 7, 8);
                drawLine(canvasCtx, lm, 0, 9); drawLine(canvasCtx, lm, 9, 10); drawLine(canvasCtx, lm, 10, 11); drawLine(canvasCtx, lm, 11, 12);
                drawLine(canvasCtx, lm, 0, 13); drawLine(canvasCtx, lm, 13, 14); drawLine(canvasCtx, lm, 14, 15); drawLine(canvasCtx, lm, 15, 16);
                drawLine(canvasCtx, lm, 0, 17); drawLine(canvasCtx, lm, 17, 18); drawLine(canvasCtx, lm, 18, 19); drawLine(canvasCtx, lm, 19, 20);
                drawLine(canvasCtx, lm, 5, 9); drawLine(canvasCtx, lm, 9, 13); drawLine(canvasCtx, lm, 13, 17); drawLine(canvasCtx, lm, 0, 17);
            }

            const lm = results.multiHandLandmarks[0];
            const index = lm[8]; const thumb = lm[4];
            const x = (1 - index.x) * window.innerWidth;
            const y = index.y * window.innerHeight;

            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';

            const dist = Math.hypot(index.x - thumb.x, index.y - thumb.y);

            if (dist < 0.05) { // Pinch
                cursor.className = 'drag';
                if(handMode !== 'DRAG') { handMode = 'DRAG'; lastHandX = x; lastHandY = y; }
                if(STATE.map) {
                    const dx = x - lastHandX;
                    const dy = y - lastHandY;
                    STATE.map.panBy([-dx, -dy], {animate: false});
                    lastHandX = x; lastHandY = y;
                }
            } else if (dist > 0.15) { // Open
                cursor.className = 'zoom';
                if(handMode !== 'ZOOM') { handMode = 'ZOOM'; zoomRefY = y; }
                if(Date.now() > STATE.zoomLock) {
                    const dy = zoomRefY - y;
                    if(Math.abs(dy) > 40) {
                        const dir = dy > 0 ? 1 : -1;
                        STATE.map.setZoom(STATE.map.getZoom() + dir);
                        zoomRefY = y;
                        STATE.zoomLock = Date.now() + 500;
                    }
                }
            } else {
                cursor.className = '';
                handMode = 'HOVER';
            }

        } else {
            cursor.style.display = 'none';
            log.innerText = "SCANNING...";
            log.style.color = "#fff";
        }
    }

</script>
</body>
</html>
